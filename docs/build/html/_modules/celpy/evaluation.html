<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>celpy.evaluation &#8212; CEL in Python  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for celpy.evaluation</h1><div class="highlight"><pre>
<span></span><span class="c1"># SPDX-Copyright: Copyright (c) Capital One Services, LLC</span>
<span class="c1"># SPDX-License-Identifier: Apache-2.0</span>
<span class="c1"># Copyright 2020 Capital One Services, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Evaluates CEL expressions given an AST.</span>

<span class="sd">There are two implementations:</span>

<span class="sd">-   Evaluator -- interprets the AST directly.</span>

<span class="sd">-   Transpiler -- transpiles the AST to Python, compiles the Python to create a code object, and then uses :py:func:`exec` to evaluate the code object.</span>

<span class="sd">The general idea is to map CEL operators to Python operators and push the</span>
<span class="sd">real work off to Python objects defined by the :py:mod:`celpy.celtypes` module.</span>

<span class="sd">CEL operator ``+`` is implemented by a ``&quot;_+_&quot;`` function.</span>
<span class="sd">We map this name to :py:func:`operator.add`.</span>
<span class="sd">This will then look for :py:meth:`__add__` methods in the various :py:mod:`celpy.celtypes`</span>
<span class="sd">types.</span>

<span class="sd">In order to deal gracefully with missing and incomplete data,</span>
<span class="sd">checked exceptions are used.</span>
<span class="sd">A raised exception is turned into first-class :py:class:`celpy.celtypes.Result` object.</span>
<span class="sd">They&#39;re not raised directly, but instead saved as part of the evaluation so that</span>
<span class="sd">short-circuit operators can ignore the exceptions.</span>

<span class="sd">This means that Python exceptions like :exc:`TypeError`, :exc:`IndexError`, and :exc:`KeyError`</span>
<span class="sd">are caught and transformed into :exc:`CELEvalError` objects.</span>

<span class="sd">The :py:class:`celpy.celtypes.Result` type hint is a union of the various values that are encountered</span>
<span class="sd">during evaluation. It&#39;s a union of the :py:class:`celpy.celtypes.CELTypes` type and the</span>
<span class="sd">:exc:`CELEvalError` exception.</span>

<span class="sd">..  important:: Debugging</span>

<span class="sd">    If the OS environment variable :envvar:`CEL_TRACE` is set, then detailed tracing of methods is made available.</span>
<span class="sd">    To see the trace, set the logging level for ``celpy.Evaluator`` to ``logging.DEBUG``.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">string</span><span class="w"> </span><span class="kn">import</span> <span class="n">Template</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">reduce</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">textwrap</span><span class="w"> </span><span class="kn">import</span> <span class="n">dedent</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Match</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Sized</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">lark</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lark.visitors</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">celpy.celtypes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">celpy.celparser</span><span class="w"> </span><span class="kn">import</span> <span class="n">tree_dump</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">re2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">function_matches</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Result&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Implementation of the ``match()`` function using ``re2``&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">re2</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">re2</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="s2">&quot;match error&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="c1"># There is a build issue with python_version==&#39;3.13&#39; and sys_platform==&#39;darwin&#39;</span>
    <span class="c1"># See https://github.com/google/re2/issues/516</span>
    <span class="c1"># We fall back to using re, which passes the essential tests</span>

<div class="viewcode-block" id="function_matches">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_matches">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">function_matches</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Result&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alternative implementation of the ``match()`` function for systems where ``re2`` can&#39;t be installed.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">re</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="s2">&quot;match error&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span></div>



<span class="c1"># An Annotation describes a union of types, functions, and function types.</span>
<span class="n">Annotation</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TypeType</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">[</span>
        <span class="o">...</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span>
    <span class="p">],</span>  <span class="c1"># Conversion functions and protobuf message type</span>
    <span class="n">Type</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">],</span>  <span class="c1"># Concrete class for annotations</span>
<span class="p">]</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;celpy.</span><span class="si">{</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="CELSyntaxError">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELSyntaxError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CELSyntaxError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CEL Syntax error -- the AST did not have the expected structure.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="CELSyntaxError.__init__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELSyntaxError.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line</span> <span class="o">=</span> <span class="n">line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span></div>
</div>



<div class="viewcode-block" id="CELUnsupportedError">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELUnsupportedError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CELUnsupportedError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feature unsupported by this implementation of CEL.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="CELUnsupportedError.__init__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELUnsupportedError.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line</span> <span class="o">=</span> <span class="n">line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span></div>
</div>



<div class="viewcode-block" id="CELEvalError">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CELEvalError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CEL evaluation problem. This can be saved as a temporary value for later use.</span>
<span class="sd">    This is politely ignored by logic operators to provide commutative short-circuit.</span>

<span class="sd">    We provide operator-like special methods so an instance of an error</span>
<span class="sd">    returns itself when operated on.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CELEvalError.__init__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">token</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">=</span> <span class="n">token</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">.</span><span class="n">line</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">.</span><span class="n">column</span></div>


<div class="viewcode-block" id="CELEvalError.__repr__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">:</span>
            <span class="c1"># This is rare</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">(*</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="si">}</span><span class="s2">, tree=</span><span class="si">{</span><span class="n">tree_dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">)</span><span class="si">!r}</span><span class="s2">, token=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="si">!r}</span><span class="s2">)&quot;</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">(*</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="si">}</span><span class="s2">, tree=</span><span class="si">{</span><span class="n">tree_dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">)</span><span class="si">!r}</span><span class="s2">)&quot;</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Some unit tests do not provide a mock tree.</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">(*</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="si">}</span><span class="s2">)&quot;</span>  <span class="c1"># pragma: no cover</span></div>


<div class="viewcode-block" id="CELEvalError.with_traceback">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.with_traceback">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_traceback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tb</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span></div>


<div class="viewcode-block" id="CELEvalError.__neg__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__neg__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__add__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__add__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__sub__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__sub__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__mul__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__mul__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__truediv__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__truediv__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__floordiv__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__floordiv__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__mod__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__mod__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__pow__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__pow__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__radd__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__radd__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__rsub__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__rsub__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__rmul__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__rmul__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__rtruediv__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__rtruediv__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__rfloordiv__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__rfloordiv__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__rmod__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__rmod__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__rpow__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__rpow__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__eq__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__eq__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">args</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


<div class="viewcode-block" id="CELEvalError.__call__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.CELEvalError.__call__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<span class="c1"># The interim results extend ``celtypes`` to include intermediate ``CELEvalError`` exception objects.</span>
<span class="c1"># These can be deferred as part of commutative logical_and and logical_or operations.</span>
<span class="c1"># It includes the responses to ``type()`` queries, also.</span>
<span class="n">Result</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span>
    <span class="n">CELEvalError</span><span class="p">,</span>
    <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">CELType</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># The various functions that apply to CEL data.</span>
<span class="c1"># The evaluator&#39;s functions expand on the CELTypes to include CELEvalError and the</span>
<span class="c1"># celpy.celtypes.CELType union type, also.</span>
<span class="n">CELFunction</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Result</span><span class="p">]</span>

<span class="c1"># A combination of a CELType result or a function resulting from identifier evaluation.</span>
<span class="n">Result_Function</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Result</span><span class="p">,</span>
    <span class="n">CELFunction</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">Exception_Filter</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">]]]</span>

<span class="n">TargetFunc</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;TargetFunc&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">CELFunction</span><span class="p">)</span>


<div class="viewcode-block" id="eval_error">
<a class="viewcode-back" href="../../api.html#celpy.__init__.eval_error">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">eval_error</span><span class="p">(</span>
    <span class="n">new_text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">exc_class</span><span class="p">:</span> <span class="n">Exception_Filter</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TargetFunc</span><span class="p">],</span> <span class="n">TargetFunc</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrap a function to transform native Python exceptions to CEL CELEvalError values.</span>
<span class="sd">    Any exception of the given class is replaced with the new CELEvalError object.</span>

<span class="sd">    :param new_text: Text of the exception, e.g., &quot;divide by zero&quot;, &quot;no such overload&quot;,</span>
<span class="sd">        this is the return value if the :exc:`CELEvalError` becomes the result.</span>
<span class="sd">    :param exc_class: A Python exception class to match, e.g. ZeroDivisionError,</span>
<span class="sd">        or a sequence of exception classes (e.g. (ZeroDivisionError, ValueError))</span>
<span class="sd">    :return: A decorator that can be applied to a function</span>
<span class="sd">        to map Python exceptions to :exc:`CELEvalError` instances.</span>

<span class="sd">    This is used in the ``all()`` and ``exists()`` macros to silently ignore TypeError exceptions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">concrete_decorator</span><span class="p">(</span><span class="n">function</span><span class="p">:</span> <span class="n">TargetFunc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetFunc</span><span class="p">:</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">new_function</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">exc_class</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>  <span class="c1"># type: ignore[misc]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(*</span><span class="si">%s</span><span class="s2">, **</span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">ex</span>
                <span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">new_text</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(*</span><span class="si">%s</span><span class="s2">, **</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="k">raise</span>

        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">TargetFunc</span><span class="p">,</span> <span class="n">new_function</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">concrete_decorator</span></div>



<div class="viewcode-block" id="boolean">
<a class="viewcode-back" href="../../api.html#celpy.__init__.boolean">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">boolean</span><span class="p">(</span>
    <span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wraps operators to create CEL BoolType results.</span>

<span class="sd">    :param function: One of the operator.lt, operator.gt, etc. comparison functions</span>
<span class="sd">    :return: Decorated function with type coercion.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bool_function</span><span class="p">(</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">:</span>
        <span class="n">result_value</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result_value</span> <span class="o">==</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">,</span> <span class="n">result_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">result_value</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">bool_function</span></div>



<div class="viewcode-block" id="operator_in">
<a class="viewcode-back" href="../../api.html#celpy.__init__.operator_in">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">operator_in</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CEL contains test; ignores type errors.</span>

<span class="sd">    During evaluation of ``&#39;elem&#39; in [1, &#39;elem&#39;, 2]``,</span>
<span class="sd">    CEL will raise internal exceptions for ``&#39;elem&#39; == 1`` and ``&#39;elem&#39; == 2``.</span>
<span class="sd">    The :exc:`TypeError` exceptions are gracefully ignored.</span>

<span class="sd">    During evaluation of ``&#39;elem&#39; in [1u, &#39;str&#39;, 2, b&#39;bytes&#39;]``, however,</span>
<span class="sd">    CEL will raise internal exceptions every step of the way, and an exception</span>
<span class="sd">    value is the final result. (Not ``False`` from the one non-exceptional comparison.)</span>

<span class="sd">    It would be nice to make use of the following::</span>

<span class="sd">        eq_test = eval_error(&quot;no such overload&quot;, TypeError)(lambda x, y: x == y)</span>

<span class="sd">    It seems like ``next(iter(filter(lambda x: eq_test(c, x) for c in container))))``</span>
<span class="sd">    would do it. But. It&#39;s not quite right for the job.</span>

<span class="sd">    There need to be three results, something :py:func:`filter` doesn&#39;t handle.</span>
<span class="sd">    These are the choices:</span>

<span class="sd">    -   True. There was a item found. Exceptions may or may not have been found.</span>
<span class="sd">    -   False. No item found AND no exceptions.</span>
<span class="sd">    -   CELEvalError. No item found AND at least one exception.</span>

<span class="sd">    To an extent this is a little like the ``exists()`` macro.</span>
<span class="sd">    We can think of ``container.contains(item)`` as ``container.exists(r, r == item)``.</span>
<span class="sd">    However, exists() tends to silence exceptions, where this can expose them.</span>

<span class="sd">    ..  todo:: This may be better done as</span>

<span class="sd">        ``reduce(logical_or, (item == c for c in container), BoolType(False))``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result_value</span><span class="p">:</span> <span class="n">Result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cast</span><span class="p">(</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">container</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;operator_in(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="n">result_value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="s2">&quot;no such overload&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;operator_in(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">) = </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">result_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result_value</span></div>



<div class="viewcode-block" id="function_size">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_size">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_size</span><span class="p">(</span><span class="n">container</span><span class="p">:</span> <span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The size() function applied to a Value.</span>
<span class="sd">    This is delegated to Python&#39;s :py:func:`len`.</span>

<span class="sd">    size(string) -&gt; int	string length</span>
<span class="sd">    size(bytes) -&gt; int	bytes length</span>
<span class="sd">    size(list(A)) -&gt; int	list size</span>
<span class="sd">    size(map(A, B)) -&gt; int	map size</span>

<span class="sd">    For other types, this will raise a Python :exc:`TypeError`.</span>
<span class="sd">    (This is captured and becomes an :exc:`CELEvalError` Result.)</span>

<span class="sd">    ..  todo:: check container type for celpy.celtypes.StringType, celpy.celtypes.BytesType,</span>
<span class="sd">        celpy.celtypes.ListType and celpy.celtypes.MapType</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">container</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sized_container</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
    <span class="n">result_value</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sized_container</span><span class="p">))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;function_size(</span><span class="si">%r</span><span class="s2">) = </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">result_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result_value</span></div>



<div class="viewcode-block" id="function_contains">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_contains">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_contains</span><span class="p">(</span>
    <span class="n">container</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span>
    <span class="p">],</span>
    <span class="n">item</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The contains() function applied to a Container and a Value.</span>
<span class="sd">    THis is delegated to the `contains` method of a class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">item</span><span class="p">)))</span></div>



<div class="viewcode-block" id="function_startsWith">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_startsWith">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_startsWith</span><span class="p">(</span>
    <span class="n">string</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">,</span> <span class="n">fragment</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">fragment</span><span class="p">))</span></div>



<div class="viewcode-block" id="function_endsWith">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_endsWith">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_endsWith</span><span class="p">(</span>
    <span class="n">string</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">,</span> <span class="n">fragment</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">fragment</span><span class="p">))</span></div>



<div class="viewcode-block" id="function_getDate">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_getDate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_getDate</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TimestampType</span><span class="p">,</span>
    <span class="n">tz_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getDate</span><span class="p">(</span><span class="n">tz_name</span><span class="p">))</span></div>



<div class="viewcode-block" id="function_getDayOfMonth">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_getDayOfMonth">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_getDayOfMonth</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TimestampType</span><span class="p">,</span>
    <span class="n">tz_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getDayOfMonth</span><span class="p">(</span><span class="n">tz_name</span><span class="p">))</span></div>



<div class="viewcode-block" id="function_getDayOfWeek">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_getDayOfWeek">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_getDayOfWeek</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TimestampType</span><span class="p">,</span>
    <span class="n">tz_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getDayOfWeek</span><span class="p">(</span><span class="n">tz_name</span><span class="p">))</span></div>



<div class="viewcode-block" id="function_getDayOfYear">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_getDayOfYear">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_getDayOfYear</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TimestampType</span><span class="p">,</span>
    <span class="n">tz_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getDayOfYear</span><span class="p">(</span><span class="n">tz_name</span><span class="p">))</span></div>



<div class="viewcode-block" id="function_getFullYear">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_getFullYear">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_getFullYear</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TimestampType</span><span class="p">,</span>
    <span class="n">tz_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getFullYear</span><span class="p">(</span><span class="n">tz_name</span><span class="p">))</span></div>



<div class="viewcode-block" id="function_getMonth">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_getMonth">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_getMonth</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TimestampType</span><span class="p">,</span>
    <span class="n">tz_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getMonth</span><span class="p">(</span><span class="n">tz_name</span><span class="p">))</span></div>



<div class="viewcode-block" id="function_getHours">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_getHours">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_getHours</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TimestampType</span><span class="p">,</span>
    <span class="n">tz_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getHours</span><span class="p">(</span><span class="n">tz_name</span><span class="p">))</span></div>



<div class="viewcode-block" id="function_getMilliseconds">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_getMilliseconds">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_getMilliseconds</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TimestampType</span><span class="p">,</span>
    <span class="n">tz_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getMilliseconds</span><span class="p">(</span><span class="n">tz_name</span><span class="p">))</span></div>



<div class="viewcode-block" id="function_getMinutes">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_getMinutes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_getMinutes</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TimestampType</span><span class="p">,</span>
    <span class="n">tz_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getMinutes</span><span class="p">(</span><span class="n">tz_name</span><span class="p">))</span></div>



<div class="viewcode-block" id="function_getSeconds">
<a class="viewcode-back" href="../../api.html#celpy.__init__.function_getSeconds">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_getSeconds</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TimestampType</span><span class="p">,</span>
    <span class="n">tz_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getSeconds</span><span class="p">(</span><span class="n">tz_name</span><span class="p">))</span></div>



<div class="viewcode-block" id="bool_lt">
<a class="viewcode-back" href="../../api.html#celpy.__init__.bool_lt">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bool_lt</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">boolean</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>



<div class="viewcode-block" id="bool_le">
<a class="viewcode-back" href="../../api.html#celpy.__init__.bool_le">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bool_le</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">boolean</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>



<div class="viewcode-block" id="bool_gt">
<a class="viewcode-back" href="../../api.html#celpy.__init__.bool_gt">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bool_gt</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">boolean</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>



<div class="viewcode-block" id="bool_ge">
<a class="viewcode-back" href="../../api.html#celpy.__init__.bool_ge">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bool_ge</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">boolean</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>



<div class="viewcode-block" id="bool_eq">
<a class="viewcode-back" href="../../api.html#celpy.__init__.bool_eq">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bool_eq</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">boolean</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>



<div class="viewcode-block" id="bool_ne">
<a class="viewcode-back" href="../../api.html#celpy.__init__.bool_ne">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bool_ne</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">boolean</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">)(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>



<span class="c1"># User-defined functions can override items in this mapping.</span>
<span class="n">base_functions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;!_&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_not</span><span class="p">,</span>
    <span class="s2">&quot;-_&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">,</span>
    <span class="s2">&quot;_+_&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
    <span class="s2">&quot;_-_&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span>
    <span class="s2">&quot;_*_&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span>
    <span class="s2">&quot;_/_&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span>
    <span class="s2">&quot;_%_&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span>
    <span class="s2">&quot;_&lt;_&quot;</span><span class="p">:</span> <span class="n">bool_lt</span><span class="p">,</span>
    <span class="s2">&quot;_&lt;=_&quot;</span><span class="p">:</span> <span class="n">bool_le</span><span class="p">,</span>
    <span class="s2">&quot;_&gt;_&quot;</span><span class="p">:</span> <span class="n">bool_gt</span><span class="p">,</span>
    <span class="s2">&quot;_&gt;=_&quot;</span><span class="p">:</span> <span class="n">bool_ge</span><span class="p">,</span>
    <span class="s2">&quot;_==_&quot;</span><span class="p">:</span> <span class="n">bool_eq</span><span class="p">,</span>
    <span class="s2">&quot;_!=_&quot;</span><span class="p">:</span> <span class="n">bool_ne</span><span class="p">,</span>
    <span class="s2">&quot;_in_&quot;</span><span class="p">:</span> <span class="n">operator_in</span><span class="p">,</span>
    <span class="s2">&quot;_||_&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_or</span><span class="p">,</span>
    <span class="s2">&quot;_&amp;&amp;_&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_and</span><span class="p">,</span>
    <span class="s2">&quot;_?_:_&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_condition</span><span class="p">,</span>
    <span class="s2">&quot;_[_]&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">,</span>
    <span class="c1"># The &quot;methods&quot; are actually named functions that can be overridden.</span>
    <span class="c1"># The function version delegates to class methods.</span>
    <span class="c1"># Yes, it&#39;s a bunch of indirection, but it permits simple overrides.</span>
    <span class="c1"># A number of types support &quot;size&quot; and &quot;contains&quot;: StringType, MapType, ListType</span>
    <span class="c1"># This is generally made available via the _in_ operator.</span>
    <span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="n">function_size</span><span class="p">,</span>
    <span class="s2">&quot;contains&quot;</span><span class="p">:</span> <span class="n">function_contains</span><span class="p">,</span>
    <span class="c1"># Universally available</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TypeType</span><span class="p">,</span>
    <span class="c1"># StringType methods, used by :py:meth:`Evaluator.method_eval`</span>
    <span class="s2">&quot;endsWith&quot;</span><span class="p">:</span> <span class="n">function_endsWith</span><span class="p">,</span>
    <span class="s2">&quot;startsWith&quot;</span><span class="p">:</span> <span class="n">function_startsWith</span><span class="p">,</span>
    <span class="s2">&quot;matches&quot;</span><span class="p">:</span> <span class="n">function_matches</span><span class="p">,</span>
    <span class="c1"># TimestampType methods. Type details are redundant, but required because of the lambdas</span>
    <span class="s2">&quot;getDate&quot;</span><span class="p">:</span> <span class="n">function_getDate</span><span class="p">,</span>
    <span class="s2">&quot;getDayOfMonth&quot;</span><span class="p">:</span> <span class="n">function_getDayOfMonth</span><span class="p">,</span>
    <span class="s2">&quot;getDayOfWeek&quot;</span><span class="p">:</span> <span class="n">function_getDayOfWeek</span><span class="p">,</span>
    <span class="s2">&quot;getDayOfYear&quot;</span><span class="p">:</span> <span class="n">function_getDayOfYear</span><span class="p">,</span>
    <span class="s2">&quot;getFullYear&quot;</span><span class="p">:</span> <span class="n">function_getFullYear</span><span class="p">,</span>
    <span class="s2">&quot;getMonth&quot;</span><span class="p">:</span> <span class="n">function_getMonth</span><span class="p">,</span>
    <span class="c1"># TimestampType and DurationType methods</span>
    <span class="s2">&quot;getHours&quot;</span><span class="p">:</span> <span class="n">function_getHours</span><span class="p">,</span>
    <span class="s2">&quot;getMilliseconds&quot;</span><span class="p">:</span> <span class="n">function_getMilliseconds</span><span class="p">,</span>
    <span class="s2">&quot;getMinutes&quot;</span><span class="p">:</span> <span class="n">function_getMinutes</span><span class="p">,</span>
    <span class="s2">&quot;getSeconds&quot;</span><span class="p">:</span> <span class="n">function_getSeconds</span><span class="p">,</span>
    <span class="c1"># type conversion functions</span>
    <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">,</span>
    <span class="s2">&quot;bytes&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BytesType</span><span class="p">,</span>
    <span class="s2">&quot;double&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">DoubleType</span><span class="p">,</span>
    <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">DurationType</span><span class="p">,</span>
    <span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">,</span>
    <span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">,</span>  <span class="c1"># https://github.com/google/cel-spec/issues/123</span>
    <span class="s2">&quot;map&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">,</span>
    <span class="s2">&quot;null_type&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span>
    <span class="s2">&quot;string&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">,</span>
    <span class="s2">&quot;timestamp&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TimestampType</span><span class="p">,</span>
    <span class="s2">&quot;uint&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">UintType</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="Referent">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Referent">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Referent</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Name can refer to any of the following things:</span>

<span class="sd">    -   ``Annotation`` -- initially most names are these.</span>
<span class="sd">        Must be provided as part of the initialization.</span>

<span class="sd">    -   ``CELFunction`` -- a Python function to implement a CEL function or method.</span>
<span class="sd">        Must be provided as part of the initialization.</span>
<span class="sd">        The type conversion functions are names in a ``NameContainer``.</span>

<span class="sd">    -   ``NameContainer`` -- some names are these.</span>
<span class="sd">        This is true when the name is *not* provided as part of the initialization because</span>
<span class="sd">        we discovered the name during type or environment binding.</span>

<span class="sd">    -   ``celpy.celtypes.Value`` -- many annotations also have values.</span>
<span class="sd">        These are provided **after** Annotations, and require them.</span>

<span class="sd">    -   ``CELEvalError`` -- This seems unlikely, but we include it because it&#39;s possible.</span>

<span class="sd">    A name can be ambiguous and refer to a nested ``NameContainer`` as well</span>
<span class="sd">    as a ``celpy.celtypes.Value`` (usually a ``MapType`` instance.)</span>

<span class="sd">    Object ``b`` has two possible meanings:</span>

<span class="sd">    -   ``b`` is a ``NameContainer`` with ``c``, a string or some other object.</span>

<span class="sd">    -   ``b`` is a ``MapType`` or ``MessageType``, and ``b.c`` is syntax sugar for ``b[&#39;c&#39;]``.</span>

<span class="sd">    The &quot;longest name&quot; rule means that the useful value is the &quot;c&quot; object</span>
<span class="sd">    in the nested ``NameContainer``.</span>
<span class="sd">    The syntax sugar interpretation is done in the rare case we can&#39;t find the ``NameContainer``.</span>

<span class="sd">    &gt;&gt;&gt; nc = NameContainer(&quot;c&quot;, celpy.celtypes.StringType)</span>
<span class="sd">    &gt;&gt;&gt; b = Referent(celpy.celtypes.MapType)</span>
<span class="sd">    &gt;&gt;&gt; b.value = celpy.celtypes.MapType({&quot;c&quot;: &quot;oops&quot;})</span>
<span class="sd">    &gt;&gt;&gt; b.value == celpy.celtypes.MapType({&quot;c&quot;: &quot;oops&quot;})</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; b.container = nc</span>
<span class="sd">    &gt;&gt;&gt; b.value == nc</span>
<span class="sd">    True</span>

<span class="sd">    ..  note:: Future Design</span>

<span class="sd">        A ``Referent`` is (almost) a ``tuple[Annotation, NameContainer | None, Value | NotSetSentinel]``.</span>
<span class="sd">        The current implementation is stateful, because values are optional and may be added later.</span>
<span class="sd">        The use of a special sentinel to indicate the value was not set is a little akward.</span>
<span class="sd">        It&#39;s not really a 3-tuple, because NameContainers don&#39;t have values; they are a kind of value.</span>
<span class="sd">        (``None`` is a valid value, and can&#39;t be used for this.)</span>

<span class="sd">        It may be slightly simpler to use a union of two types:</span>
<span class="sd">        ``tuple[Annotation] | tuple[Annotation, NameContainer | Value]``.</span>
<span class="sd">        One-tuples capture the Annotation for a name; two-tuples capture Annotation and Value (or subsidiary NameContainer).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Referent.__init__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Referent.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ref_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Annotation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1"># TODO: Add value here, also, as a handy short-cut to avoid the value setter.</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Annotation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">container</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;NameContainer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">Annotation</span><span class="p">,</span>
            <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span>
            <span class="n">CELEvalError</span><span class="p">,</span>
            <span class="n">CELFunction</span><span class="p">,</span>
            <span class="s2">&quot;NameContainer&quot;</span><span class="p">,</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_set</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Should NOT be private.</span>
        <span class="k">if</span> <span class="n">ref_to</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">annotation</span> <span class="o">=</span> <span class="n">ref_to</span></div>


<div class="viewcode-block" id="Referent.__repr__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Referent.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(annotation=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">annotation</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;container=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">container</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;_value=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="si">!r}</span><span class="s2">)&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Referent.__eq__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Referent.__eq__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># TODO: When minimum version &gt;= 3.10, use match statement</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">same</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">annotation</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">annotation</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">container</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">container</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_set</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_value_set</span>
                <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_value</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_set</span> <span class="k">else</span> <span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">same</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>  <span class="c1"># pragma: no cover</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Annotation</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">,</span> <span class="s2">&quot;NameContainer&quot;</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The longest-path rule means we prefer ``NameContainer`` over any locally defined value.</span>
<span class="sd">        Otherwise, we&#39;ll provide a value if there is one.</span>
<span class="sd">        Finally, we&#39;ll provide the annotation if there&#39;s no value.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">container</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">container</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_set</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Not part of a namespace path. Nor was a value set.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotation</span>

    <span class="nd">@value</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ref_to</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">Annotation</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">,</span> <span class="s2">&quot;NameContainer&quot;</span>
        <span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">ref_to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_set</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Referent.clone">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Referent.clone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Referent&quot;</span><span class="p">:</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">Referent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">container</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">container</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_value_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_set</span>
        <span class="k">return</span> <span class="n">new</span></div>
</div>



<span class="c1"># A name resolution context is a mapping from an identifier to a Value or a ``NameContainer``.</span>
<span class="c1"># This reflects some murkiness in the name resolution algorithm that needs to be cleaned up.</span>
<span class="n">Context</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="s2">&quot;NameContainer&quot;</span><span class="p">,</span> <span class="s2">&quot;CELFunction&quot;</span><span class="p">]]</span>


<span class="c1"># Copied from cel.lark</span>
<span class="n">IDENT</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[_a-zA-Z][_a-zA-Z0-9]*&quot;</span>


<div class="viewcode-block" id="NameContainer">
<a class="viewcode-back" href="../../api.html#celpy.__init__.NameContainer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NameContainer</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Referent</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A namespace that fulfills the CEL name resolution requirement.</span>

<span class="sd">    ::</span>

<span class="sd">        Scenario: &quot;qualified_identifier_resolution_unchecked&quot;</span>
<span class="sd">          &quot;namespace resolution should try to find the longest prefix for the evaluator.&quot;</span>

<span class="sd">    NameContainer instances can be chained (via parent) to create a sequence of searchable</span>
<span class="sd">    locations for a name.</span>

<span class="sd">    -   Local-most is an Activation with local variables within a macro.</span>
<span class="sd">        These are part of a nested chain of Activations for each macro. Each local activation</span>
<span class="sd">        is a child with a reference to the parent Activation.</span>

<span class="sd">    -   Parent of any local Activation is the overall Activation for this CEL evaluation.</span>
<span class="sd">        The overall Activation contains a number of NameContainers:</span>

<span class="sd">        -   The global variable bindings.</span>

<span class="sd">        -   Bindings of function definitions. This is the default set of functions for CEL</span>
<span class="sd">            plus any add-on functions introduced by C7N.</span>

<span class="sd">        -   The run-time annotations from the environment. There are two kinds:</span>

<span class="sd">            -   Protobuf message definitions. These are types, really.</span>

<span class="sd">            -   Annotations for global variables. The annotations tend to be hidden by the values.</span>
<span class="sd">                They&#39;re in the lookup chain to simplify access to protobuf messages.</span>

<span class="sd">        -   The environment also provides the built-in type names and aliases for the</span>
<span class="sd">            :mod:`celtypes` package of built-in types.</span>

<span class="sd">    This means name resolution marches from local-most to remote-most, searching for a binding.</span>
<span class="sd">    The global variable bindings have a local-most value and a more remote annotation.</span>
<span class="sd">    The annotations (i.e. protobuf message types) have only a fairly remote annotation without</span>
<span class="sd">    a value.</span>

<span class="sd">    ..  rubric:: Structure</span>

<span class="sd">    A ``NameContainer`` is a mapping from names to ``Referent`` instances.</span>

<span class="sd">    A `Referent` can be one of several things, including...</span>

<span class="sd">    -   A NameContainer further down the path</span>
<span class="sd">    -   An Annotation</span>
<span class="sd">    -   An Annotation and a value</span>
<span class="sd">    -   A CELFunction (In effect, an Annotation of CELFunction, and a value of the function implementation.)</span>

<span class="sd">    ..  rubric:: Life and Content</span>

<span class="sd">    There are two phases to building the chain of ``NameContainer`` instances.</span>

<span class="sd">    1.  The ``Activation`` creates the initial ``name : annotation`` bindings.</span>
<span class="sd">        Generally, the names are type names, like &quot;int&quot;, bound to :py:class:`celtypes.IntType`.</span>
<span class="sd">        In some cases, the name is a future variable name, &quot;resource&quot;,</span>
<span class="sd">        bound to :py:class:`celtypes.MapType`.</span>

<span class="sd">    2.  The ``Activation`` updates some variables to provide values.</span>

<span class="sd">    A name is decomposed into a path to make a tree of nested ``NameContainers``.</span>
<span class="sd">    Upper-level containers don&#39;t (necessarily) have types or values -- they&#39;re merely</span>
<span class="sd">    ``NameContainer`` along the path to the target names.</span>

<span class="sd">    ..  rubric:: Resolving Names</span>

<span class="sd">    See https://github.com/google/cel-spec/blob/master/doc/langdef.md#name-resolution</span>

<span class="sd">    There are three cases required in the :py:class:`Evaluator` engine.</span>

<span class="sd">    -   Variables and Functions. These are ``Result_Function`` instances: i.e., ordinary values.</span>

<span class="sd">    -   ``Name.Name`` can be navigation into a protobuf package, when ``Name`` is protobuf package.</span>
<span class="sd">        The idea is to locate the longest possible match.</span>

<span class="sd">        If a.b is a name to be resolved in the context of a protobuf declaration with scope A.B,</span>
<span class="sd">        then resolution is attempted, in order, as A.B.a.b, A.a.b, and finally a.b.</span>
<span class="sd">        To override this behavior, one can use .a.b;</span>
<span class="sd">        this name will only be attempted to be resolved in the root scope, i.e. as a.b.</span>

<span class="sd">    -   ``Name.Name`` can be syntactic sugar for indexing into a mapping when ``Name`` is a value of</span>
<span class="sd">        ``MapType`` or a ``MessageType``. It&#39;s evaluated as if it was ``Name[&quot;Name&quot;]``.</span>
<span class="sd">        This is a fall-back plan if the previous resolution failed.</span>

<span class="sd">    The longest chain of nested packages *should* be resolved first.</span>
<span class="sd">    This will happen when each name is a ``NameContainer`` object containing</span>
<span class="sd">    other ``NameContainer`` objects.</span>

<span class="sd">    The chain of evaluations for ``IDENT . IDENT . IDENT`` is (in effect)</span>
<span class="sd">    ::</span>

<span class="sd">        member_dot(member_dot(primary(IDENT), IDENT), IDENT)</span>

<span class="sd">    This makes the ``member_dot`` processing left associative.</span>

<span class="sd">    The ``primary(IDENT)`` resolves to a CEL object of some kind.</span>
<span class="sd">    Once the ``primary(IDENT)`` has been resolved, it establishes a context</span>
<span class="sd">    for subsequent ``member_dot`` methods.</span>

<span class="sd">    -   If this is a ``MapType`` or a ``MessageType`` with an object,</span>
<span class="sd">        then ``member_dot`` will pluck out a field value and return this.</span>

<span class="sd">    -   If this is a ``NameContainer`` or a ``PackageType`` then the ``member_dot``</span>
<span class="sd">        will pluck out a sub-package or ``EnumType`` or ``MessageType``</span>
<span class="sd">        and return the type object instead of a value.</span>
<span class="sd">        At some point a ``member_object`` production will build an object from the type.</span>

<span class="sd">    The evaluator&#39;s :meth:`ident_value` method resolves the identifier into the ``Referent``.</span>

<span class="sd">    ..  rubric:: Acceptance Test Cases</span>

<span class="sd">    We have two names</span>

<span class="sd">    -   `a.b` -&gt; NameContainer in which c = &quot;yeah&quot;. (i.e., a.b.c : &quot;yeah&quot;)</span>
<span class="sd">    -   `a.b` -&gt; Mapping with {&quot;c&quot;: &quot;oops&quot;}.</span>

<span class="sd">    This means any given name can have as many as three meanings:</span>

<span class="sd">    -   Primarily as a NameContainer. This resolves name.name.name to find the longest</span>
<span class="sd">        namespace possible.</span>

<span class="sd">    -   Secondarily as a Mapping. This will be a fallback when name.name.name is really</span>
<span class="sd">        syntactic sugar for name.name[&#39;name&#39;].</span>

<span class="sd">    -   Finally as a type annotation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ident_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">IDENT</span><span class="p">)</span>
    <span class="n">extended_name_path</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;^</span><span class="se">\\</span><span class="s2">.?</span><span class="si">{</span><span class="n">IDENT</span><span class="si">}</span><span class="s2">(?:</span><span class="se">\\</span><span class="s2">.</span><span class="si">{</span><span class="n">IDENT</span><span class="si">}</span><span class="s2">)*$&quot;</span><span class="p">)</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;celpy.NameContainer&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="NameContainer.__init__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.NameContainer.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ref_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Referent</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;NameContainer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">ref_to</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">ref_to</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NameContainer</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span></div>


<div class="viewcode-block" id="NameContainer.load_annotations">
<a class="viewcode-back" href="../../api.html#celpy.__init__.NameContainer.load_annotations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_annotations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used by an ``Activation`` to build a container used to resolve</span>
<span class="sd">        long path names into nested NameContainers.</span>
<span class="sd">        Sets annotations for all supplied identifiers.</span>

<span class="sd">        ``{&quot;name1.name2&quot;: annotation}`` becomes two things:</span>

<span class="sd">        1. nc2 = NameContainer({&quot;name2&quot; : Referent(annotation)})</span>

<span class="sd">        2. nc1 = NameContainer({&quot;name1&quot; : Referent(nc2)})</span>

<span class="sd">        :param names: A dictionary of {&quot;name1.name1....&quot;: Referent, ...} items.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">refers_to</span> <span class="ow">in</span> <span class="n">names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># self.logger.debug(&quot;load_annotations %r : %r&quot;, name, refers_to)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_name_path</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span>

            <span class="c1"># Expand &quot;name1.name2....&quot;: refers_to into [&quot;name1&quot;, &quot;name2&quot;, ...]: refers_to</span>
            <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ident_pat</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Referent</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">container</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ref</span><span class="o">.</span><span class="n">container</span> <span class="o">=</span> <span class="n">NameContainer</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
                <span class="n">context</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">container</span>
            <span class="n">context</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="n">Referent</span><span class="p">(</span><span class="n">refers_to</span><span class="p">))</span></div>


<div class="viewcode-block" id="NameContainer.load_values">
<a class="viewcode-back" href="../../api.html#celpy.__init__.NameContainer.load_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update any annotations with actual values.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">refers_to</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># self.logger.debug(&quot;load_values %r : %r&quot;, name, refers_to)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_name_path</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span>

            <span class="c1"># Expand &quot;name1.name2....&quot;: refers_to into [&quot;name1&quot;, &quot;name2&quot;, ...]: refers_to</span>
            <span class="c1"># Update NameContainer(&quot;name1&quot;, NameContainer(&quot;name2&quot;, NameContainer(..., refers_to)))</span>
            <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ident_pat</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Referent</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">container</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ref</span><span class="o">.</span><span class="n">container</span> <span class="o">=</span> <span class="n">NameContainer</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
                <span class="n">context</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">container</span>
            <span class="n">context</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="n">Referent</span><span class="p">())</span>  <span class="c1"># No annotation previously present.</span>
            <span class="n">context</span><span class="p">[</span><span class="n">final</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">refers_to</span></div>


<div class="viewcode-block" id="NameContainer.NotFound">
<a class="viewcode-back" href="../../api.html#celpy.__init__.NameContainer.NotFound">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">NotFound</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raised locally when a name is not found in the middle of package search.</span>
<span class="sd">        We can&#39;t return ``None`` from find_name because that&#39;s a valid value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">pass</span></div>


<div class="viewcode-block" id="NameContainer.dict_find_name">
<a class="viewcode-back" href="../../api.html#celpy.__init__.NameContainer.dict_find_name">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dict_find_name</span><span class="p">(</span>
        <span class="n">some_dict</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Referent</span><span class="p">],</span> <span class="n">Referent</span><span class="p">],</span> <span class="n">path</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Referent</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursive navigation into mappings, messages, and packages.</span>
<span class="sd">        These are not NameContainers (or Activations).</span>

<span class="sd">        :param some_dict: An instance of a ``MapType``, ``MessageType``, or ``PackageType``.</span>
<span class="sd">        :param path: sequence of names to follow into the structure.</span>
<span class="sd">        :returns: Value found down inside the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">NameContainer</span><span class="o">.</span><span class="n">dict_find_name</span><span class="p">(</span>
                    <span class="n">cast</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Referent</span><span class="p">],</span> <span class="n">some_dict</span><span class="p">)[</span><span class="n">head</span><span class="p">],</span> <span class="n">tail</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">NameContainer</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> not found in </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">head</span><span class="p">,</span>
                    <span class="n">cast</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Referent</span><span class="p">],</span> <span class="n">some_dict</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">NameContainer</span><span class="o">.</span><span class="n">NotFound</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># End of the path, we found it.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">some_dict</span><span class="p">,</span> <span class="n">Referent</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
                <span class="c1"># Seems unlikely, but, just to be sure...</span>
                <span class="k">return</span> <span class="n">some_dict</span>
            <span class="n">referent</span> <span class="o">=</span> <span class="n">Referent</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">)</span>
            <span class="n">referent</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">,</span> <span class="n">some_dict</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">referent</span></div>


<div class="viewcode-block" id="NameContainer.find_name">
<a class="viewcode-back" href="../../api.html#celpy.__init__.NameContainer.find_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Referent</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the name by searching down through nested packages or raise NotFound.</span>
<span class="sd">        Returns the Value associated with this Name.</span>

<span class="sd">        This is a kind of in-order tree walk of contained packages.</span>

<span class="sd">        The collaborator must choose the annotation or the value from the Referent.</span>

<span class="sd">        ..  todo:: Refactored to return Referent.</span>

<span class="sd">            The collaborator must handle two distinct errors:</span>

<span class="sd">            1.  ``self[head]`` has a ``KeyError`` exception -- while not found on this path, the collaborator should keep searching.</span>
<span class="sd">                Eventually it will raise a final ``KeyError`` that maps to a ``CELEvalError``</span>
<span class="sd">                This should be exposed as f&quot;no such member in mapping: {ex.args[0]!r}&quot;</span>

<span class="sd">            2.  ``self[head].value`` has no value and the ``Referent`` returned the annotation instead of the value.</span>
<span class="sd">                In transpiled Python code, this **should** be exposed as f&quot;undeclared reference to {ex.args[0]!r} (in container {ex.args[1]!r})&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="c1"># Already fully matched. This ``NameContainer`` is what they were looking for.</span>
            <span class="n">referent</span> <span class="o">=</span> <span class="n">Referent</span><span class="p">()</span>
            <span class="n">referent</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">referent</span>

        <span class="c1"># Find the head of the path.</span>
        <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">path</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sub_context</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">head</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> not found in </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="k">raise</span> <span class="n">NameContainer</span><span class="o">.</span><span class="n">NotFound</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tail</span><span class="p">:</span>
            <span class="c1"># Found what they were looking for</span>
            <span class="k">return</span> <span class="n">sub_context</span>

        <span class="c1"># There are several special cases for the continued search.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> </span><span class="si">%r</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">sub_context</span><span class="p">)</span>

        <span class="c1"># We found a NameContainer, simple recursion will do.</span>
        <span class="n">item</span><span class="p">:</span> <span class="n">Referent</span>
        <span class="k">if</span> <span class="n">sub_context</span><span class="o">.</span><span class="n">container</span><span class="p">:</span>  <span class="c1"># isinstance(sub_context, NameContainer):</span>
            <span class="k">return</span> <span class="n">sub_context</span><span class="o">.</span><span class="n">container</span><span class="o">.</span><span class="n">find_name</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>

        <span class="c1"># Uncommon case: value with no annotation, and the value is a Message, Mapping, or Package</span>
        <span class="k">elif</span> <span class="n">sub_context</span><span class="o">.</span><span class="n">_value_set</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">sub_context</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MessageType</span><span class="p">,</span>
                <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">,</span>
                <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">PackageType</span><span class="p">,</span>
                <span class="nb">dict</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">NameContainer</span><span class="o">.</span><span class="n">dict_find_name</span><span class="p">(</span>
                <span class="n">cast</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Referent</span><span class="p">],</span> <span class="n">sub_context</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">tail</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">item</span>

        <span class="c1"># A primitive type, but not at the end of the path. Ugn.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sub_context</span><span class="si">!r}</span><span class="s2"> not a container&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="NameContainer.parent_iter">
<a class="viewcode-back" href="../../api.html#celpy.__init__.NameContainer.parent_iter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parent_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s2">&quot;NameContainer&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Yield this NameContainer and all of its parents to create a flat list.&quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent_iter</span><span class="p">()</span></div>


<div class="viewcode-block" id="NameContainer.resolve_name">
<a class="viewcode-back" href="../../api.html#celpy.__init__.NameContainer.resolve_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resolve_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">package</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Referent</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search with less and less package prefix until we find the thing.</span>

<span class="sd">        Resolution works as follows.</span>
<span class="sd">        If a.b is a name to be resolved in the context of a protobuf declaration with scope A.B,</span>
<span class="sd">        then resolution is attempted, in order, as</span>

<span class="sd">        1. A.B.a.b.  (Search for &quot;a&quot; in package &quot;A.B&quot;; the &quot;.b&quot; is handled separately.)</span>

<span class="sd">        2. A.a.b.  (Search for &quot;a&quot; in package &quot;A&quot;; the &quot;.b&quot; is handled separately.)</span>

<span class="sd">        3. (finally) a.b.  (Search for &quot;a&quot; in package None; the &quot;.b&quot; is handled separately.)</span>

<span class="sd">        To override this behavior, one can use .a.b;</span>
<span class="sd">        this name will only be attempted to be resolved in the root scope, i.e. as a.b.</span>

<span class="sd">        We Start with the longest package name, a ``List[str]`` assigned to ``target``.</span>

<span class="sd">        Given a target, search through this ``NameContainer`` and all parents in the</span>
<span class="sd">        :meth:`parent_iter` iterable.</span>
<span class="sd">        The first name we find in the parent sequence is the goal.</span>
<span class="sd">        This is because values are first, type annotations are last.</span>

<span class="sd">        If we can&#39;t find the identifier with given package target,</span>
<span class="sd">        truncate the package name from the end to create a new target and try again.</span>
<span class="sd">        This is a bottom-up look that favors the longest name.</span>

<span class="sd">        :param package: Prefix string &quot;path.path.path&quot;</span>
<span class="sd">        :param name: The variable we&#39;re looking for</span>
<span class="sd">        :return: Name resolution as a ``Rereferent``, often a value, but maybe a package or an</span>
<span class="sd">            annotation.</span>
<span class="sd">        :raises KeyError: if the name cannot be found in this ``NameContainer``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;resolve_name(</span><span class="si">%r</span><span class="s2">.</span><span class="si">%r</span><span class="s2">) in </span><span class="si">%s</span><span class="s2">, parent=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">package</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Longest Name</span>
        <span class="k">if</span> <span class="n">package</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ident_pat</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">package</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
        <span class="c1"># Pool of matches</span>
        <span class="n">matches</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Referent</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Target has an extra item to make the len non-zero.</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">matches</span> <span class="ow">and</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">nc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_iter</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">package_ident</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span> <span class="o">+</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="c1"># Find the Referent for this name.</span>
                    <span class="n">ref_to</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">find_name</span><span class="p">(</span><span class="n">package_ident</span><span class="p">)</span>
                    <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">package_ident</span><span class="p">,</span> <span class="n">ref_to</span><span class="p">))</span>
                <span class="k">except</span> <span class="n">NameContainer</span><span class="o">.</span><span class="n">NotFound</span><span class="p">:</span>
                    <span class="c1"># No matches; move to the parent and try again.</span>
                    <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;resolve_name: target=</span><span class="si">%s</span><span class="s2">+[</span><span class="si">%r</span><span class="s2">], matches=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">matches</span>
            <span class="p">)</span>
        <span class="c1"># NOTE: There are two separate kinds of failures: no name at all, and no value for the name.</span>
        <span class="c1"># This is the no name at all. The collaborator may need the value or the annotation.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># Find the longest name match and return the Referent.</span>
        <span class="c1"># This feels hackish -- it should be the first referent value.</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">best_match</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">path_value</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">best_match</span></div>


<div class="viewcode-block" id="NameContainer.clone">
<a class="viewcode-back" href="../../api.html#celpy.__init__.NameContainer.clone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;NameContainer&quot;</span><span class="p">:</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">NameContainer</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new</span></div>


<div class="viewcode-block" id="NameContainer.get">
<a class="viewcode-back" href="../../api.html#celpy.__init__.NameContainer.get">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span>  <span class="c1"># type: ignore[override]</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Referent</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Annotation</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">,</span> <span class="s2">&quot;NameContainer&quot;</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used by transpiled code to get values from a NameContainer of Referents.</span>

<span class="sd">        ..  important:: This does not get a Referent, it gets a value.</span>

<span class="sd">        ..  todo:: This is a poorly-chosen name; a number of related types **all** need to have a get_value() method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">value</span></div>


<div class="viewcode-block" id="NameContainer.__repr__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.NameContainer.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">, parent=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="si">}</span><span class="s2">)&quot;</span></div>
</div>



<div class="viewcode-block" id="Activation">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Activation">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Activation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Namespace with variable bindings and type name (&quot;annotation&quot;) bindings.</span>
<span class="sd">    Additionally, the pool of functions and types are here, also.</span>

<span class="sd">    ..  rubric:: Life and Content</span>

<span class="sd">    An Activation is created by an Environment and contains the annotations</span>
<span class="sd">    (and a package name) from that Environment. Variables are loaded into the</span>
<span class="sd">    activation for evaluation.</span>

<span class="sd">    A nested Activation is created each time we evaluate a macro.</span>

<span class="sd">    An Activation contains a ``NameContainer`` instance to resolve identifiers.</span>
<span class="sd">    (This may be a needless distinction and the two classes could, perhaps, be combined.)</span>

<span class="sd">    These names include variables as well as type names used for protobuf and the internal CEL ``type()`` function.</span>

<span class="sd">    ..  rubric:: Chaining/Nesting</span>

<span class="sd">    Activations can form a chain so locals are checked first.</span>
<span class="sd">    Activations can nest via macro evaluation, creating transient local variables.</span>

<span class="sd">    Consider this CEL macro expression:</span>
<span class="sd">    ::</span>

<span class="sd">        ``&quot;[2, 4, 6].map(n, n / 2)&quot;``</span>

<span class="sd">    This works via a nested activation with ``n`` bound to 2, 4, and 6 respectively.</span>

<span class="sd">    This is used by an :py:class:`Evaluator` as follows::</span>

<span class="sd">        sub_activation: Activation = self.activation.nested_activation()</span>
<span class="sd">        sub_eval: Evaluator = self.sub_eval(sub_activation)</span>
<span class="sd">        sub_eval_partial: Callable[[Value], Value] = sub_eval.partial(</span>
<span class="sd">            tree_for_variable, tree_for_expression)</span>
<span class="sd">        push(celtypes.ListType(map(sub_eval_partial, pop()))</span>

<span class="sd">    The ``localized_eval()`` creates a new :py:class:`Activation`</span>
<span class="sd">    and an associated :py:class:`Evaluator` for this nested activation context.</span>
<span class="sd">    It uses the :py:class:`Evaluator.visit` method to evaluate the given expression for</span>
<span class="sd">    a new object bound to the given variable.</span>

<span class="sd">    ..  rubric:: Namespace Creation</span>

<span class="sd">    We expand ``{&quot;a.b.c&quot;: 42}`` to create nested namespaces: ``{&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: 42}}}``.</span>

<span class="sd">    This depends on two syntax rules to define the valid names::</span>

<span class="sd">        member        : primary</span>
<span class="sd">                      | member &quot;.&quot; IDENT [&quot;(&quot; [exprlist] &quot;)&quot;]</span>

<span class="sd">        primary       : [&quot;.&quot;] IDENT [&quot;(&quot; [exprlist] &quot;)&quot;]</span>

<span class="sd">    Ignore the ``[&quot;(&quot; [exprlist] &quot;)&quot;]`` options used for member functions.</span>
<span class="sd">    We have members and primaries, both of which depend on the following lexical rule::</span>

<span class="sd">        IDENT         : /[_a-zA-Z][_a-zA-Z0-9]*/</span>

<span class="sd">    Name expansion is handled in order of length. Here&#39;s why::</span>

<span class="sd">        Scenario: &quot;qualified_identifier_resolution_unchecked&quot;</span>
<span class="sd">              &quot;namespace resolution should try to find the longest prefix for the evaluator.&quot;</span>

<span class="sd">    Most names start with ``IDENT``, but a primary can start with ``.``.</span>
<span class="sd">    A leading ``.`` changes the search order from most local first to root first.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Activation.__init__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Activation.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>  <span class="c1"># Keyword only, too many things here.</span>
        <span class="n">annotations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">vars</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Context</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">functions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">CELFunction</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">package</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">based_on</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Activation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an Activation.</span>

<span class="sd">        The annotations are loaded first. The variables and their values are loaded second, and placed</span>
<span class="sd">        in front of the annotations in the chain of name resolutions.</span>

<span class="sd">        The Evaluator and the Transpiler use this to resolve identifiers into types, values, or functions.</span>

<span class="sd">        :keyword annotations: Variables and type annotations.</span>
<span class="sd">            Annotations are loaded first to serve as defaults to create a parent NameContainer.</span>
<span class="sd">        :keyword vars: Variables and their values, loaded to update the NameContainer.</span>
<span class="sd">        :keyword functions: functions and their implementation, loaded to update the NameContainer.</span>
<span class="sd">        :keyword package: The package name to assume as a prefix for name resolution.</span>
<span class="sd">        :keyword based_on: A foundational activation on which this is based.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Activation(annotations=</span><span class="si">%r</span><span class="s2">, vars=</span><span class="si">%r</span><span class="s2">, functions=</span><span class="si">%r</span><span class="s2">, package=</span><span class="si">%r</span><span class="s2">, based_on=</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
            <span class="n">annotations</span><span class="p">,</span>
            <span class="nb">vars</span><span class="p">,</span>
            <span class="n">functions</span><span class="p">,</span>
            <span class="n">package</span><span class="p">,</span>
            <span class="n">based_on</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Seed the annotations for identifiers in this activation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="p">:</span> <span class="n">NameContainer</span> <span class="o">=</span> <span class="n">NameContainer</span><span class="p">(</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">based_on</span><span class="o">.</span><span class="n">identifiers</span> <span class="k">if</span> <span class="n">based_on</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">annotations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">load_annotations</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Set values from a dictionary of names and values.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">load_values</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>

        <span class="c1"># Update this NameContainer functions (if any.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span> <span class="n">collections</span><span class="o">.</span><span class="n">ChainMap</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">local_functions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span> <span class="ow">or</span> <span class="p">[]</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">ChainMap</span><span class="p">(</span><span class="n">local_functions</span><span class="p">,</span> <span class="n">base_functions</span><span class="p">)</span>
            <span class="c1"># self.identifiers.load_values(local_functions)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">ChainMap</span><span class="p">(</span>
                <span class="n">cast</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">],</span> <span class="n">functions</span><span class="p">),</span> <span class="n">base_functions</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">functions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">ChainMap</span><span class="p">(</span><span class="n">base_functions</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;functions not a mapping or sequence&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="c1"># The name of the run-time package -- an assumed prefix for name resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">package</span> <span class="o">=</span> <span class="n">package</span></div>


<div class="viewcode-block" id="Activation.clone">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Activation.clone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Activation&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a clone of this activation with a deep copy of the identifiers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Cloning an Activation...&quot;</span><span class="p">)</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="n">Activation</span><span class="p">()</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">identifiers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">package</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;clone: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clone</span></div>


<div class="viewcode-block" id="Activation.nested_activation">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Activation.nested_activation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nested_activation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">annotations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Remove this.</span>
        <span class="nb">vars</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Context</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Activation&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an Activation based on the current activation.</span>
<span class="sd">        This new Activation will be seeded from the current activation&#39;s</span>
<span class="sd">        ``NameContainer``.</span>

<span class="sd">        :param annotations: Optional type definitions for the new local variables.</span>
<span class="sd">        :param vars: Local variables to be added when creating this activation.</span>
<span class="sd">        :return: A subsidiary ``Activation`` that chains to this Activation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Creating nested Activation...&quot;</span><span class="p">)</span>
        <span class="n">nested</span> <span class="o">=</span> <span class="n">Activation</span><span class="p">(</span>
            <span class="n">annotations</span><span class="o">=</span><span class="n">annotations</span><span class="p">,</span>  <span class="c1"># Replace with self.annotations.</span>
            <span class="nb">vars</span><span class="o">=</span><span class="nb">vars</span><span class="p">,</span>
            <span class="n">functions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">,</span>
            <span class="n">package</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="p">,</span>
            <span class="n">based_on</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;nested: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nested</span></div>


<div class="viewcode-block" id="Activation.resolve_variable">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Activation.resolve_variable">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resolve_variable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">,</span> <span class="n">NameContainer</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the object referred to by the name.</span>

<span class="sd">        An Activation usually has a chain of NameContainers to be searched.</span>

<span class="sd">        A variable can refer to an annotation and/or a value and/or a nested</span>
<span class="sd">        container.  Most of the time, we want the `value` attribute of the Referent.</span>
<span class="sd">        This can be a Result (a Union[Value, CelType])</span>

<span class="sd">        There&#39;s a subtle difference between a variable without an annotation,</span>
<span class="sd">        and a variable with an annotation, but without a value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Will be a Referent. Get Value or Type -- interpreter works with either.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;resolve_variable(</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">referent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">NameContainer</span><span class="p">],</span> <span class="n">referent</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


<div class="viewcode-block" id="Activation.resolve_function">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Activation.resolve_function">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resolve_function</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">CELFunction</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TypeType</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A short-cut to find functions without looking at Variables first.&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;resolve_function(</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


<div class="viewcode-block" id="Activation.__getattr__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Activation.__getattr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">,</span> <span class="n">NameContainer</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handle ``activation.name`` in transpiled code (or ``activation.get(&#39;name&#39;)``).</span>

<span class="sd">        If the name is not in the Activation with a value, a ``NameError`` exception must be raised.</span>

<span class="sd">        Note that :py:meth:`Activation.resolve_variable` depends on :py:meth:`NameContainer.find_name`.</span>
<span class="sd">        The :py:meth:`NameContainer.find_name` method **also** find the value.</span>

<span class="sd">        This is -- perhaps -- less than optimal because it can mask the no value set case.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Will be a Referent. Get Value if it was set or raise error if no value set.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">referent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;get/__getattr__(</span><span class="si">%r</span><span class="s2">) ==&gt; </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">referent</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">referent</span><span class="o">.</span><span class="n">_value_set</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">NameContainer</span><span class="p">],</span> <span class="n">referent</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">referent</span><span class="o">.</span><span class="n">container</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">referent</span><span class="o">.</span><span class="n">container</span>
                <span class="k">elif</span> <span class="n">referent</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">NameContainer</span><span class="p">],</span> <span class="n">referent</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Corrupt </span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;get/__getattr__(</span><span class="si">%r</span><span class="s2">) fallback to functions&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


    <span class="n">get</span> <span class="o">=</span> <span class="fm">__getattr__</span>

<div class="viewcode-block" id="Activation.__repr__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Activation.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(annotations=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">parent</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;package=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;vars=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;functions=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;parent=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">parent</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="trace">
<a class="viewcode-back" href="../../api.html#celpy.__init__.trace">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">trace</span><span class="p">(</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;Evaluator&quot;</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;Evaluator&quot;</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to create consistent evaluation trace logging.</span>
<span class="sd">    This is generally applied to the methods matching parse rule names.</span>

<span class="sd">    This only works for a class with a ``level`` attribute, like :py:class:`Evaluator`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">concrete_method</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;Evaluator&quot;</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">*</span> <span class="s2">&quot;| &quot;</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
        <span class="n">result_value</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2"> -&gt; </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">*</span> <span class="s2">&quot;| &quot;</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">result_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result_value</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CEL_TRACE&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">concrete_method</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">method</span></div>



<div class="viewcode-block" id="Evaluator">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Evaluator</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">visitors</span><span class="o">.</span><span class="n">Interpreter</span><span class="p">[</span><span class="n">Result</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate an AST in the context of a specific Activation.</span>

<span class="sd">    See https://github.com/google/cel-go/blob/master/examples/README.md</span>

<span class="sd">    General Evaluation.</span>

<span class="sd">    An AST node must call ``self.visit_children(tree)`` explicitly</span>
<span class="sd">    to build the values for all the children of this node.</span>

<span class="sd">    ..  rubric:: Exceptions</span>

<span class="sd">    To handle ``2 / 0 || true``, the ``||``, ``&amp;&amp;``, and ``?:`` operators</span>
<span class="sd">    do not trivially evaluate and raise exceptions. They bottle up the</span>
<span class="sd">    exceptions and treat them as a kind of undecided value.</span>

<span class="sd">    ..  rubric:: Identifiers</span>

<span class="sd">    Identifiers have three meanings:</span>

<span class="sd">    -   An object. This is either a variable provided in the activation or a function provided</span>
<span class="sd">        when building an execution. Objects also have type annotations.</span>

<span class="sd">    -   A type annotation without an object. This is used to build protobuf messages.</span>

<span class="sd">    -   A macro name. The ``member_dot_arg`` construct may have a macro.</span>
<span class="sd">        Plus the ``ident_arg`` construct may also have a ``dyn()`` or ``has()`` macro.</span>
<span class="sd">        See below for more.</span>

<span class="sd">    Other than macros, a name maps to an ``Referent`` instance.</span>
<span class="sd">    This will have an annotation and -- perhaps -- an associated object.</span>

<span class="sd">    Names have nested paths. ``a.b.c`` is a mapping, ``a``, that contains a mapping, ``b``,</span>
<span class="sd">    that contains ``c``.</span>

<span class="sd">    ..  important MACROS ARE SPECIAL</span>

<span class="sd">        They aren&#39;t simple functions.</span>

<span class="sd">        The macros do not **all** simply visit their children to perform evaluation.</span>

<span class="sd">    There are three cases:</span>

<span class="sd">    - ``dyn()`` does effectively nothing.</span>
<span class="sd">      It visits its children, but also provides progressive type resolution</span>
<span class="sd">      through annotation of the AST.</span>

<span class="sd">    - ``has()`` attempts to visit the child and does a boolean transformation</span>
<span class="sd">      on the result.</span>
<span class="sd">      This is a macro because it doesn&#39;t raise an exception for a missing</span>
<span class="sd">      member item reference, but instead maps an exception to False.</span>
<span class="sd">      It doesn&#39;t return the value found for a member item reference; instead, it maps</span>
<span class="sd">      this to True.</span>

<span class="sd">    - The various ``member.macro()`` constructs do **NOT** visit children.</span>
<span class="sd">      They create a nested evaluation environment for the child variable name and expression.</span>

<span class="sd">    The :py:meth:`member` method implements the macro evaluation behavior.</span>
<span class="sd">    It does not **always** trivially descend into the children.</span>
<span class="sd">    In the case of macros, the member evaluates one child tree in the presence</span>
<span class="sd">    of values from another child tree using specific variable binding in a kind</span>
<span class="sd">    of stack frame.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;celpy.Evaluator&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Evaluator.__init__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ast</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span>
        <span class="n">activation</span><span class="p">:</span> <span class="n">Activation</span><span class="p">,</span>
        <span class="c1"># functions: Union[Sequence[CELFunction], Mapping[str, CELFunction], None] = None,  # Refactor into Activation</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an evaluator for an AST with specific variables and functions.</span>

<span class="sd">        :param ast: The AST to evaluate.</span>
<span class="sd">        :param activation: The variable bindings to use.</span>
<span class="sd">        :param functions: The functions to use. If nothing is supplied, the default</span>
<span class="sd">            global `base_functions` are used. Otherwise, a ``ChainMap`` is created so</span>
<span class="sd">            these local functions override the base functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ast</span> <span class="o">=</span> <span class="n">ast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_activation</span> <span class="o">=</span> <span class="n">activation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_activation</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Evaluator activation: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span></div>

        <span class="c1"># self.logger.debug(&quot;functions: %r&quot;, self.functions)  # Refactor ``self.functions`` into an Activation</span>

<div class="viewcode-block" id="Evaluator.sub_evaluator">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.sub_evaluator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sub_evaluator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Evaluator&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an evaluator for a sub-expression in a macro.</span>

<span class="sd">        :param ast: The AST for the expression in the macro.</span>
<span class="sd">        :return: A new `Evaluator` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Evaluator</span><span class="p">(</span><span class="n">ast</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.set_activation">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.set_activation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_activation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Evaluator&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new activation using the given Context.</span>
<span class="sd">        This is used for two things:</span>

<span class="sd">        1. Bind external variables. Examples are command-line arguments and environment variables.</span>

<span class="sd">        2. Build local variable(s) for macro evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_activation</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">load_values</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Activation: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Evaluator.ident_value">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.ident_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ident_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">root_scope</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result_Function</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resolve names in the current activation.</span>
<span class="sd">        This includes variables, functions, the type registry for conversions,</span>
<span class="sd">        and protobuf packages, as well as protobuf types.</span>

<span class="sd">        We may be limited to root scope, which prevents searching through alternative</span>
<span class="sd">        protobuf package definitions.</span>
<span class="sd">        In principle, this changes the order of the search.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># try:</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_variable</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

        <span class="c1"># except KeyError:</span>
        <span class="c1"># return self.functions[name]  # Refactor ``self.functions`` into an Activation</span>

<div class="viewcode-block" id="Evaluator.evaluate">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.evaluate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Context</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate this AST and return the value or raise an exception.</span>

<span class="sd">        There are two variant use cases.</span>

<span class="sd">        -   External clients want the value or the exception.</span>

<span class="sd">        -   Internally, we sometimes want to silence ``CELEvalError`` exceptions so that</span>
<span class="sd">            we can apply short-circuit logic and choose a non-exceptional result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">context</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_activation</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.visit_children">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.visit_children">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visit_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extend the superclass to track nesting and current evaluation context.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">result_value</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result_value</span></div>


<div class="viewcode-block" id="Evaluator.function_eval">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.function_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">function_eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name_token</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">exprlist</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Result</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function evaluation.</span>

<span class="sd">        - Object creation and type conversions.</span>
<span class="sd">        - Other functions like ``size()`` or ``type()``</span>
<span class="sd">        - Extension functions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">function</span><span class="p">:</span> <span class="n">CELFunction</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># TODO: Transitive Lookup of function in all parent activation contexts.</span>
            <span class="c1"># function = self.functions[name_token.value]  # Refactor ``self.functions`` into an Activation</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_function</span><span class="p">(</span><span class="n">name_token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;undeclared reference to &#39;</span><span class="si">{</span><span class="n">name_token</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(in activation &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>
            <span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">name_token</span><span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exprlist</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">exprlist</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">list_exprlist</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">exprlist</span> <span class="ow">or</span> <span class="p">[])</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">list_exprlist</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                <span class="s2">&quot;return error for overflow&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">name_token</span>
            <span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;function_eval(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name_token</span><span class="p">,</span> <span class="n">exprlist</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                <span class="s2">&quot;no such overload&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">name_token</span>
            <span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="Evaluator.method_eval">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.method_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">method_eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="nb">object</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span>
        <span class="n">method_ident</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span>
        <span class="n">exprlist</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Result</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method evaluation. While these are (nominally) attached to an object,</span>
<span class="sd">        that would make overrides complicated.</span>
<span class="sd">        Instead, these are functions (which can be overridden).</span>
<span class="sd">        The object must the first parameter to a function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">function</span><span class="p">:</span> <span class="n">CELFunction</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># TODO: Transitive Lookup of function in all parent activation contexts.</span>
            <span class="c1"># function = self.functions[method_ident.value]  # Refactor ``self.functions`` into an Activation</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_function</span><span class="p">(</span><span class="n">method_ident</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;method_eval(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="n">method_ident</span><span class="p">,</span> <span class="n">exprlist</span><span class="p">,</span> <span class="n">ex</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;functions: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">functions</span>
            <span class="p">)</span>  <span class="c1"># Refactor ``self.functions`` into an Activation</span>
            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;undeclared reference to </span><span class="si">{</span><span class="n">method_ident</span><span class="o">.</span><span class="n">value</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(in activation &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>
            <span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">method_ident</span><span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">object</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exprlist</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">exprlist</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">list_exprlist</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">exprlist</span> <span class="ow">or</span> <span class="p">[])</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="o">*</span><span class="n">list_exprlist</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                <span class="s2">&quot;return error for overflow&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">method_ident</span>
            <span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;method_eval(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="n">method_ident</span><span class="p">,</span> <span class="n">exprlist</span><span class="p">,</span> <span class="n">ex</span>
            <span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                <span class="s2">&quot;no such overload&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">method_ident</span>
            <span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="Evaluator.macro_has_eval">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.macro_has_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">macro_has_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprlist</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The has(e.f) macro.</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#field-selection</span>

<span class="sd">        1.  If e evaluates to a map, then has(e.f) indicates whether the string f is a</span>
<span class="sd">            key in the map (note that f must syntactically be an identifier).</span>

<span class="sd">        2.  If e evaluates to a message and f is not a declared field for the message,</span>
<span class="sd">            has(e.f) raises a no_such_field error.</span>

<span class="sd">        3.  If e evaluates to a protocol buffers version 2 message and f is a defined field:</span>

<span class="sd">            - If f is a repeated field or map field, has(e.f) indicates whether the field is</span>
<span class="sd">              non-empty.</span>

<span class="sd">            - If f is a singular or &quot;oneof&quot; field, has(e.f) indicates whether the field is set.</span>

<span class="sd">        4.  If e evaluates to a protocol buffers version 3 message and f is a defined field:</span>

<span class="sd">            - If f is a repeated field or map field, has(e.f) indicates whether the field is</span>
<span class="sd">              non-empty.</span>

<span class="sd">            - If f is a &quot;oneof&quot; field or singular message field, has(e.f) indicates whether the field</span>
<span class="sd">              is set.</span>

<span class="sd">            - If f is some other singular field, has(e.f) indicates whether the field&#39;s value</span>
<span class="sd">              is its default value (zero for numeric fields, false for booleans,</span>
<span class="sd">              empty for strings and bytes).</span>

<span class="sd">        5.  In all other cases, has(e.f) evaluates to an error.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">has_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">exprlist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">has_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">CELEvalError</span><span class="p">))</span></div>


<div class="viewcode-block" id="Evaluator.expr">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.expr">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        expr           : conditionalor [&quot;?&quot; conditionalor &quot;:&quot; expr]</span>

<span class="sd">        The default implementation short-circuits</span>
<span class="sd">        and can ignore a CELEvalError in the two alternative sub-expressions.</span>
<span class="sd">        The conditional sub-expression CELEvalError is propagated out as the result.</span>

<span class="sd">        See https://github.com/google/cel-spec/blob/master/doc/langdef.md#logical-operators</span>

<span class="sd">        &gt; To get traditional left-to-right short-circuiting evaluation of logical operators,</span>
<span class="sd">        as in C or other languages (also called &quot;McCarthy Evaluation&quot;),</span>
<span class="sd">        the expression e1 &amp;&amp; e2 can be rewritten `e1 ? e2 : false`.</span>
<span class="sd">        Similarly, `e1 || e2` can be rewritten `e1 ? true : e2`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># expr is a single conditionalor.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># full conditionalor &quot;?&quot; conditionalor &quot;:&quot; expr.</span>
            <span class="c1"># func = self.functions[&quot;_?_:_&quot;]    # Refactor ``self.functions`` into an Activation</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_function</span><span class="p">(</span><span class="s2">&quot;_?_:_&quot;</span><span class="p">)</span>
            <span class="n">cond_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cond_value</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">cond_value</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for _?_:_ &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">cond_value</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad expr node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.conditionalor">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.conditionalor">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">conditionalor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        conditionalor  : [conditionalor &quot;||&quot;] conditionaland</span>

<span class="sd">        The default implementation short-circuits</span>
<span class="sd">        and can ignore an CELEvalError in a sub-expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># conditionaland with no preceding conditionalor.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># func = self.functions[&quot;_||_&quot;]   # Refactor ``self.functions`` into an Activation</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_function</span><span class="p">(</span><span class="s2">&quot;_||_&quot;</span><span class="p">)</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">Result</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for _||_ &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad conditionalor node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.conditionaland">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.conditionaland">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">conditionaland</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        conditionaland : [conditionaland &quot;&amp;&amp;&quot;] relation</span>

<span class="sd">        The default implementation short-circuits</span>
<span class="sd">        and can ignore an CELEvalError in a sub-expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># relation with no preceding conditionaland.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># func = self.functions[&quot;_&amp;&amp;_&quot;]    # Refactor ``self.functions`` into an Activation</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_function</span><span class="p">(</span><span class="s2">&quot;_&amp;&amp;_&quot;</span><span class="p">)</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">Result</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for _&amp;&amp;_ &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad conditionalor node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.relation">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.relation">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">relation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        relation       : [relation_lt | relation_le | relation_ge | relation_gt</span>
<span class="sd">                       | relation_eq | relation_ne | relation_in] addition</span>

<span class="sd">        relation_lt    : relation &quot;&lt;&quot;</span>
<span class="sd">        relation_le    : relation &quot;&lt;=&quot;</span>
<span class="sd">        relation_gt    : relation &quot;&gt;&quot;</span>
<span class="sd">        relation_ge    : relation &quot;&gt;=&quot;</span>
<span class="sd">        relation_eq    : relation &quot;==&quot;</span>
<span class="sd">        relation_ne    : relation &quot;!=&quot;</span>
<span class="sd">        relation_in    : relation &quot;in&quot;</span>

<span class="sd">        This could be refactored into separate methods to skip the lookup.</span>

<span class="sd">        Ideally::</span>

<span class="sd">            values = self.visit_children(tree)</span>
<span class="sd">            func = functions[op_name_map[tree.data]]</span>
<span class="sd">            result_value = func(*values)</span>

<span class="sd">        The AST doesn&#39;t provide a flat list of values, however.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># addition with no preceding relation.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">left_op</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="c1"># Map a node data in parse tree to an operation function.</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;relation_lt&quot;</span><span class="p">:</span> <span class="s2">&quot;_&lt;_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_le&quot;</span><span class="p">:</span> <span class="s2">&quot;_&lt;=_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_ge&quot;</span><span class="p">:</span> <span class="s2">&quot;_&gt;=_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_gt&quot;</span><span class="p">:</span> <span class="s2">&quot;_&gt;_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_eq&quot;</span><span class="p">:</span> <span class="s2">&quot;_==_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_ne&quot;</span><span class="p">:</span> <span class="s2">&quot;_!=_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_in&quot;</span><span class="p">:</span> <span class="s2">&quot;_in_&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="c1"># func = self.functions[op_name]    # Refactor ``self.functions`` into an Activation</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_function</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
            <span class="c1"># NOTE: values have the structure [[left], right]</span>
            <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">),</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">Result</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;relation </span><span class="si">%r</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for </span><span class="si">{</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad relation node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.addition">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.addition">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">addition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        addition       : [addition_add | addition_sub] multiplication</span>

<span class="sd">        addition_add   : addition &quot;+&quot;</span>
<span class="sd">        addition_sub   : addition &quot;-&quot;</span>

<span class="sd">        This could be refactored into separate methods to skip the lookup.</span>

<span class="sd">        Ideally::</span>

<span class="sd">            values = self.visit_children(tree)</span>
<span class="sd">            func = functions[op_name_map[tree.data]]</span>
<span class="sd">            result_value = func(*values)</span>

<span class="sd">        The AST doesn&#39;t provide a flat list of values, however.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># multiplication with no preceding addition.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">left_op</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="c1"># Map a node data in parse tree to an operation function.</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;addition_add&quot;</span><span class="p">:</span> <span class="s2">&quot;_+_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;addition_sub&quot;</span><span class="p">:</span> <span class="s2">&quot;_-_&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="c1"># func = self.functions[op_name]    # Refactor ``self.functions`` into an Activation</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_function</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
            <span class="c1"># NOTE: values have the structure [[left], right]</span>
            <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">),</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">Result</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;addition </span><span class="si">%r</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for </span><span class="si">{</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                    <span class="s2">&quot;return error for overflow&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span>
                <span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad addition node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.multiplication">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.multiplication">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">multiplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        multiplication : [multiplication_mul | multiplication_div | multiplication_mod] unary</span>

<span class="sd">        multiplication_mul : multiplication &quot;*&quot;</span>
<span class="sd">        multiplication_div : multiplication &quot;/&quot;</span>
<span class="sd">        multiplication_mod : multiplication &quot;%&quot;</span>

<span class="sd">        This could be refactored into separate methods to skip the lookup.</span>

<span class="sd">        Ideally::</span>

<span class="sd">                values = self.visit_children(tree)</span>
<span class="sd">                func = functions[op_name_map[tree.data]]</span>
<span class="sd">                result_value = func(*values)</span>

<span class="sd">        The AST doesn&#39;t provide a flat list of values, however.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># unary with no preceding multiplication.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">left_op</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="c1"># Map a node data in parse tree to an operation function.</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;multiplication_div&quot;</span><span class="p">:</span> <span class="s2">&quot;_/_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;multiplication_mul&quot;</span><span class="p">:</span> <span class="s2">&quot;_*_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;multiplication_mod&quot;</span><span class="p">:</span> <span class="s2">&quot;_%_&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="c1"># func = self.functions[op_name]   # Refactor ``self.functions`` into an Activation</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_function</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
            <span class="c1"># NOTE: values have the structure [[left], right]</span>
            <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">),</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">Result</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;multiplication </span><span class="si">%r</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for </span><span class="si">{</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                    <span class="s2">&quot;modulus or divide by zero&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span>
                <span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                    <span class="s2">&quot;return error for overflow&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span>
                <span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad multiplication node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.unary">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.unary">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        unary          : [unary_not | unary_neg] member</span>

<span class="sd">        unary_not      : &quot;!&quot;</span>
<span class="sd">        unary_neg      : &quot;-&quot;</span>

<span class="sd">        This should be refactored into separate methods to skip the lookup.</span>

<span class="sd">        ideally::</span>

<span class="sd">            values = self.visit_children(tree)</span>
<span class="sd">            func = functions[op_name_map[tree.data]]</span>
<span class="sd">            result_value = func(*values)</span>

<span class="sd">        But, values has the structure ``[[], right]``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># member with no preceding unary_not or unary_neg</span>
            <span class="c1"># TODO: If there are two possible values (namespace v. mapping) chose the namespace.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">op_tree</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="c1"># Map a node data in parse tree to an operation function.</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;unary_not&quot;</span><span class="p">:</span> <span class="s2">&quot;!_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;unary_neg&quot;</span><span class="p">:</span> <span class="s2">&quot;-_&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">op_tree</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="c1"># func = self.functions[op_name]    # Refactor ``self.functions`` into an Activation</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_function</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
            <span class="c1"># NOTE: values has the structure [[], right]</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">Result</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;unary </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for </span><span class="si">{</span><span class="n">op_tree</span><span class="o">.</span><span class="n">data</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                    <span class="s2">&quot;return error for overflow&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span>
                <span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad unary node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.build_macro_eval">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.build_macro_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_macro_eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds macro function.</span>

<span class="sd">        For example</span>

<span class="sd">            ``[1, 2, 3].map(n, n/2)``</span>

<span class="sd">        Builds the function = ``lambda n: n/2``.</span>

<span class="sd">        The function will expose exceptions, disabling short-circuit ``||`` and ``&amp;&amp;``.</span>

<span class="sd">        The `child` is a `member_dot_arg` construct:</span>

<span class="sd">        - [0] is the expression to the left of the &#39;.&#39;</span>

<span class="sd">        - [1] is the function, `map`, to the right of the `.`</span>

<span class="sd">        - [2] is the arguments in ()&#39;s.</span>
<span class="sd">          Within this, there are two children: a variable and an expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">var_tree</span><span class="p">,</span> <span class="n">expr_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">args</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="n">idents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">var_tree</span><span class="o">.</span><span class="n">find_data</span><span class="p">(</span><span class="s2">&quot;ident&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idents</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Essentially impossible.</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>  <span class="c1"># pragma: no cover</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad macro node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">identifier</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">idents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">value</span>
        <span class="n">nested_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_evaluator</span><span class="p">(</span><span class="n">ast</span><span class="o">=</span><span class="n">expr_tree</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">sub_expr</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nested_eval</span><span class="o">.</span><span class="n">evaluate</span><span class="p">({</span><span class="n">identifier</span><span class="p">:</span> <span class="n">v</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">sub_expr</span></div>


<div class="viewcode-block" id="Evaluator.build_ss_macro_eval">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.build_ss_macro_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_ss_macro_eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds macro function for short-circuit logical evaluation ignoring exception values.</span>

<span class="sd">        For example</span>

<span class="sd">            ``[1, 2, &#39;hello&#39;].exists(n, n &gt;= 2)``</span>

<span class="sd">        Builds the function = ``lambda n: n &gt;= 2``.</span>

<span class="sd">        The function will swallow exceptions, enabling short-circuit ``||`` and ``&amp;&amp;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">var_tree</span><span class="p">,</span> <span class="n">expr_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">args</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="n">idents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">var_tree</span><span class="o">.</span><span class="n">find_data</span><span class="p">(</span><span class="s2">&quot;ident&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idents</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Essentially impossible.</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>  <span class="c1"># pragma: no cover</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad macro node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">identifier</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">idents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">value</span>
        <span class="c1"># identifier = FindIdent.in_tree(var_tree)</span>
        <span class="c1"># if identifier is None:  # pragma: no cover</span>
        <span class="c1">#     # This seems almost impossible.</span>
        <span class="c1">#     raise CELSyntaxError(</span>
        <span class="c1">#         f&quot;{child.data} {child.children}: bad macro node&quot;,</span>
        <span class="c1">#         line=child.meta.line,</span>
        <span class="c1">#         column=child.meta.column,</span>
        <span class="c1">#     )</span>
        <span class="c1"># nested_eval = Evaluator(ast=expr_tree, activation=self.activation)</span>
        <span class="n">nested_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_evaluator</span><span class="p">(</span><span class="n">ast</span><span class="o">=</span><span class="n">expr_tree</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">sub_expr</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">nested_eval</span><span class="o">.</span><span class="n">evaluate</span><span class="p">({</span><span class="n">identifier</span><span class="p">:</span> <span class="n">v</span><span class="p">})</span>
            <span class="k">except</span> <span class="n">CELEvalError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ex</span>

        <span class="k">return</span> <span class="n">sub_expr</span></div>


<div class="viewcode-block" id="Evaluator.build_reduce_macro_eval">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.build_reduce_macro_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_reduce_macro_eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Result</span><span class="p">,</span> <span class="n">Result</span><span class="p">],</span> <span class="n">Result</span><span class="p">],</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds macro function and initial expression for reduce().</span>

<span class="sd">        For example</span>

<span class="sd">            ``[0, 1, 2].reduce(r, i, 0, r + 2*i+1)``</span>

<span class="sd">        Builds the function = ``lambda r, i: r + 2*i+1`` and initial value = 0.</span>

<span class="sd">        The `child` is a `member_dot_arg` construct:</span>

<span class="sd">        - [0] is the expression to the left of the &#39;.&#39;</span>

<span class="sd">        - [1] is the function, `reduce`, to the right of the `.`</span>

<span class="sd">        - [2] is the arguments in ()&#39;s.</span>
<span class="sd">          Within this, there are four children: two variables and two expressions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">reduce_var_tree</span><span class="p">,</span> <span class="n">iter_var_tree</span><span class="p">,</span> <span class="n">init_expr_tree</span><span class="p">,</span> <span class="n">expr_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">args</span><span class="o">.</span><span class="n">children</span>
        <span class="p">)</span>
        <span class="n">reduce_idents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">reduce_var_tree</span><span class="o">.</span><span class="n">find_data</span><span class="p">(</span><span class="s2">&quot;ident&quot;</span><span class="p">))</span>
        <span class="n">iter_idents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iter_var_tree</span><span class="o">.</span><span class="n">find_data</span><span class="p">(</span><span class="s2">&quot;ident&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduce_idents</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">iter_idents</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># This seems almost impossible.</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad macro node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">reduce_ident</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">reduce_idents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">value</span>
        <span class="n">iter_ident</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">iter_idents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">value</span>
        <span class="c1"># reduce_ident = FindIdent.in_tree(reduce_var_tree)</span>
        <span class="c1"># iter_ident = FindIdent.in_tree(iter_var_tree)</span>
        <span class="c1"># if reduce_ident is None or iter_ident is None:  # pragma: no cover</span>
        <span class="c1">#     # This seems almost impossible.</span>
        <span class="c1">#     raise CELSyntaxError(</span>
        <span class="c1">#         f&quot;{child.data} {child.children}: bad macro node&quot;,</span>
        <span class="c1">#         line=child.meta.line,</span>
        <span class="c1">#         column=child.meta.column,</span>
        <span class="c1">#     )</span>
        <span class="c1"># nested_eval = Evaluator(ast=expr_tree, activation=self.activation)</span>
        <span class="n">nested_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_evaluator</span><span class="p">(</span><span class="n">ast</span><span class="o">=</span><span class="n">expr_tree</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">sub_expr</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nested_eval</span><span class="o">.</span><span class="n">evaluate</span><span class="p">({</span><span class="n">reduce_ident</span><span class="p">:</span> <span class="n">r</span><span class="p">,</span> <span class="n">iter_ident</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">sub_expr</span><span class="p">,</span> <span class="n">init_expr_tree</span></div>


<div class="viewcode-block" id="Evaluator.member">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.member">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member         : member_dot | member_dot_arg | member_item | member_object | primary</span>

<span class="sd">        member_dot     : member &quot;.&quot; IDENT</span>
<span class="sd">        member_dot_arg : member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        member_item    : member &quot;[&quot; expr &quot;]&quot;</span>
<span class="sd">        member_object  : member &quot;{&quot; [fieldinits] &quot;}&quot;</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#field-selection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="Evaluator.member_dot">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.member_dot">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">member_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member         : member_dot | member_dot_arg | member_item | member_object | primary</span>

<span class="sd">        member_dot     : member &quot;.&quot; IDENT</span>
<span class="sd">        member_dot_arg : member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        member_item    : member &quot;[&quot; expr &quot;]&quot;</span>
<span class="sd">        member_object  : member &quot;{&quot; [fieldinits] &quot;}&quot;</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#name-resolution</span>

<span class="sd">        -   ``primary``: Variables and Functions: some simple names refer to variables in the</span>
<span class="sd">            execution context, standard functions, or other name bindings provided by the CEL</span>
<span class="sd">            application.</span>

<span class="sd">        -   ``member_dot``: Field selection: appending a period and identifier to an expression</span>
<span class="sd">            could indicate that we&#39;re accessing a field within a protocol buffer or map.</span>
<span class="sd">            See below for **Field Selection**.</span>

<span class="sd">        -   ``member_dot``: Protocol buffer package names: a simple or qualified name could</span>
<span class="sd">            represent an absolute or relative name in the protocol buffer package namespace.</span>
<span class="sd">            Package names must be followed by a message type, enum type, or enum constant.</span>

<span class="sd">        -   ``member_dot``: Protocol buffer message types, enum types, and enum constants:</span>
<span class="sd">            following an optional protocol buffer package name, a simple or qualified name</span>
<span class="sd">            could refer to a message type, and enum type, or an enum constant in the package&#39;s</span>
<span class="sd">            namespace.</span>

<span class="sd">        Field Selection. There are four cases.</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#field-selection</span>

<span class="sd">        - If e evaluates to a message</span>
<span class="sd">          and f is not declared in this message, the runtime error no_such_field is raised.</span>

<span class="sd">        - If e evaluates to a message</span>
<span class="sd">          and f is declared, but the field is not set,</span>
<span class="sd">          the default value of the field&#39;s type will be produced.</span>

<span class="sd">        - If e evaluates to a map, then e.f is equivalent to e[&#39;f&#39;].</span>

<span class="sd">        - In all other cases, e.f evaluates to an error.</span>

<span class="sd">        TODO: implement member &quot;.&quot; IDENT for protobuf message types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">member_tree</span><span class="p">,</span> <span class="n">property_name_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span>
        <span class="p">)</span>
        <span class="n">member</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">member_tree</span><span class="p">)</span>
        <span class="n">property_name</span> <span class="o">=</span> <span class="n">property_name_token</span><span class="o">.</span><span class="n">value</span>
        <span class="n">result_value</span><span class="p">:</span> <span class="n">Result</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
            <span class="n">result_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">member</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">NameContainer</span><span class="p">):</span>
            <span class="c1"># Navigation through names provided as external run-time bindings.</span>
            <span class="c1"># The dict is the value of a Referent that was part of a namespace path.</span>
            <span class="k">if</span> <span class="n">property_name</span> <span class="ow">in</span> <span class="n">member</span><span class="p">:</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">member</span><span class="p">[</span><span class="n">property_name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;No </span><span class="si">{</span><span class="n">property_name</span><span class="si">!r}</span><span class="s2"> in bindings </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">member</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MessageType</span><span class="p">):</span>
            <span class="c1"># NOTE: Message&#39;s don&#39;t have a &quot;default None&quot; behavior: they raise an exception.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;member_dot(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">property_name</span><span class="p">)</span>
            <span class="n">result_value</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">property_name</span><span class="p">)</span>
        <span class="c1"># TODO: Future Expansion, handle Protobuf message package...</span>
        <span class="c1"># elif isinstance(member, celpy.celtypes.PackageType):</span>
        <span class="c1">#     if property_name in member:</span>
        <span class="c1">#         result_value = member[property_name]</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         err = f&quot;no such message {property_name!r} in package {member}&quot;</span>
        <span class="c1">#         result_value = CELEvalError(err, KeyError, None, tree=tree)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">):</span>
            <span class="c1"># Syntactic sugar: a.b is a[&quot;b&quot;] when ``a`` is a mapping.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">member</span><span class="p">[</span><span class="n">property_name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;no such member in mapping: </span><span class="si">{</span><span class="n">property_name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">member</span><span class="si">!r}</span><span class="s2"> with type: &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">member</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; does not support field selection&quot;</span>
            <span class="n">result_value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result_value</span></div>


<div class="viewcode-block" id="Evaluator.member_dot_arg">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.member_dot_arg">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">member_dot_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member         : member_dot | member_dot_arg | member_item | member_object | primary</span>

<span class="sd">        member_dot     : member &quot;.&quot; IDENT</span>
<span class="sd">        member_dot_arg : member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        member_item    : member &quot;[&quot; expr &quot;]&quot;</span>
<span class="sd">        member_object  : member &quot;{&quot; [fieldinits] &quot;}&quot;</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#field-selection</span>

<span class="sd">        Method or macro? We Distinguish between these three similar cases.</span>

<span class="sd">        - Macros: https://github.com/google/cel-spec/blob/master/doc/langdef.md#macros</span>

<span class="sd">        - member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot; -- used for string operations</span>

<span class="sd">        - member &quot;.&quot; IDENT &quot;(&quot; &quot;)&quot;  -- used for a several timestamp operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sub_expr</span><span class="p">:</span> <span class="n">CELFunction</span>
        <span class="n">result_value</span><span class="p">:</span> <span class="n">Result</span>
        <span class="n">reduction</span><span class="p">:</span> <span class="n">Result</span>
        <span class="n">CELBoolFunction</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">,</span> <span class="n">Result</span><span class="p">],</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span>
        <span class="p">]</span>

        <span class="n">member_tree</span><span class="p">,</span> <span class="n">method_name_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">{</span>
            <span class="s2">&quot;map&quot;</span><span class="p">,</span>
            <span class="s2">&quot;filter&quot;</span><span class="p">,</span>
            <span class="s2">&quot;all&quot;</span><span class="p">,</span>
            <span class="s2">&quot;exists&quot;</span><span class="p">,</span>
            <span class="s2">&quot;exists_one&quot;</span><span class="p">,</span>
            <span class="c1"># Extensions to CEL...</span>
            <span class="s2">&quot;reduce&quot;</span><span class="p">,</span>
            <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="p">}:</span>
            <span class="c1"># TODO: These can be refactored to share the macro_xyz() functions</span>
            <span class="c1"># used by Transpiled code.</span>

            <span class="n">member_list</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">member_tree</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member_list</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">member_list</span>

            <span class="k">if</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;map&quot;</span><span class="p">:</span>
                <span class="n">sub_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_macro_eval</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">mapping</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">Iterable</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="nb">map</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">,</span> <span class="n">member_list</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result_value</span>

            <span class="k">elif</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;filter&quot;</span><span class="p">:</span>
                <span class="n">sub_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_macro_eval</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">,</span> <span class="n">member_list</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">result_value</span>

            <span class="k">elif</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                <span class="n">sub_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_ss_macro_eval</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">and_oper</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">CELBoolFunction</span><span class="p">,</span>
                    <span class="n">eval_error</span><span class="p">(</span><span class="s2">&quot;no such overload&quot;</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)(</span>
                        <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_and</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="n">reduction</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                    <span class="n">and_oper</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">,</span> <span class="n">member_list</span><span class="p">),</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">reduction</span>

            <span class="k">elif</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;exists&quot;</span><span class="p">:</span>
                <span class="n">sub_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_ss_macro_eval</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">or_oper</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">CELBoolFunction</span><span class="p">,</span>
                    <span class="n">eval_error</span><span class="p">(</span><span class="s2">&quot;no such overload&quot;</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)(</span>
                        <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_or</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="n">reduction</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                    <span class="n">or_oper</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">,</span> <span class="n">member_list</span><span class="p">),</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">reduction</span>

            <span class="k">elif</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;exists_one&quot;</span><span class="p">:</span>
                <span class="c1"># Is there exactly 1?</span>
                <span class="n">sub_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_macro_eval</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">member_list</span> <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
                <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Not formally part of CEL...</span>
            <span class="k">elif</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;reduce&quot;</span><span class="p">:</span>
                <span class="c1"># Apply a function to reduce the list to a single value.</span>
                <span class="c1"># The `tree` is a `member_dot_arg` construct with (member, method_name, args)</span>
                <span class="c1"># The args have two variables and two expressions.</span>
                <span class="n">reduce_expr</span><span class="p">,</span> <span class="n">init_expr_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_reduce_macro_eval</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">initial_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">init_expr_tree</span><span class="p">)</span>
                <span class="n">reduction</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">reduce_expr</span><span class="p">,</span> <span class="n">member_list</span><span class="p">,</span> <span class="n">initial_value</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">reduction</span>

            <span class="c1"># Not formally part of CEL...</span>
            <span class="k">elif</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
                <span class="c1"># Special case of &quot;reduce()&quot;</span>
                <span class="c1"># with &lt;member&gt;.min() -&gt; &lt;member&gt;.reduce(r, i, int_max, r &lt; i ? r : i)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Note. The Result type includes None, which will raise an exception.</span>
                    <span class="n">reduction</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">member_list</span><span class="p">)</span>  <span class="c1"># type: ignore [type-var]</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                    <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Attempt to reduce an empty sequence or a sequence with a None value&quot;</span>
                    <span class="n">reduction</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">reduction</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Internal Design Error&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Not a macro: a method evaluation.</span>
            <span class="c1"># Evaluate member, method IDENT and (if present) exprlist and apply.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">member</span><span class="p">,</span> <span class="n">ident</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">Tuple</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_eval</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">ident</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># assert len(tree.children) == 3</span>
                <span class="n">member</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">expr_iter</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">Tuple</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Result</span><span class="p">]],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_eval</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">expr_iter</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result_value</span></div>


<div class="viewcode-block" id="Evaluator.member_index">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.member_index">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">member_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member         : member_dot | member_dot_arg | member_item | member_object | primary</span>

<span class="sd">        member_dot     : member &quot;.&quot; IDENT</span>
<span class="sd">        member_dot_arg : member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        member_item    : member &quot;[&quot; expr &quot;]&quot;</span>
<span class="sd">        member_object  : member &quot;{&quot; [fieldinits] &quot;}&quot;</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#field-selection</span>

<span class="sd">        Locating an item in a Mapping or List</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># func = self.functions[&quot;_[_]&quot;]    # Refactor ``self.functions`` into an Activation</span>
        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_function</span><span class="p">(</span><span class="s2">&quot;_[_]&quot;</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="n">member</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;found no matching overload for _[_] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">member</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
            <span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="s2">&quot;no such key&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="s2">&quot;invalid_argument&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="Evaluator.member_object">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.member_object">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">member_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member         : member_dot | member_dot_arg | member_item | member_object | primary</span>

<span class="sd">        member_dot     : member &quot;.&quot; IDENT</span>
<span class="sd">        member_dot_arg : member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        member_item    : member &quot;[&quot; expr &quot;]&quot;</span>
<span class="sd">        member_object  : member &quot;{&quot; [fieldinits] &quot;}&quot;</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#field-selection</span>

<span class="sd">        An object constructor requires a protobyf type, not an object as the &quot;member&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># primary | member &quot;{&quot; &quot;}&quot;</span>
            <span class="k">if</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;primary&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Build a default protobuf message.</span>
                <span class="n">protobuf_class</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Creating </span><span class="si">%s</span><span class="s2">()&quot;</span><span class="p">,</span> <span class="n">protobuf_class</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">protobuf_class</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Created </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># protobuf feature:  member &quot;{&quot; fieldinits &quot;}&quot;</span>
            <span class="n">member</span><span class="p">,</span> <span class="n">fieldinits</span> <span class="o">=</span> <span class="n">values</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">member</span>
            <span class="c1"># Apply fieldinits as the constructor for an instance of the referenced type.</span>
            <span class="n">protobuf_class</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">member</span><span class="p">)</span>
            <span class="c1"># NOTE: protobuf MessageType conversions are the responsibility of the target type.</span>
            <span class="c1"># We can&#39;t -- easily -- generalize this.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Creating </span><span class="si">%s</span><span class="s2">(</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">protobuf_class</span><span class="p">,</span> <span class="n">fieldinits</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">protobuf_class</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">fieldinits</span><span class="p">))</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Created </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad member_object node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.primary">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.primary">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">primary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        primary        : dot_ident_arg | dot_ident | ident_arg | ident</span>
<span class="sd">                       | paren_expr | list_lit | map_lit | literal</span>

<span class="sd">        dot_ident_arg  : &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        dot_ident      : &quot;.&quot; IDENT</span>
<span class="sd">        ident_arg      : IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        ident          : IDENT</span>
<span class="sd">        paren_expr     : &quot;(&quot; expr &quot;)&quot;</span>
<span class="sd">        list_lit       : &quot;[&quot; [exprlist] &quot;]&quot;</span>
<span class="sd">        map_lit        : &quot;{&quot; [mapinits] &quot;}&quot;</span>

<span class="sd">        .. TODO:: Refactor into separate methods to skip these complex elif chain.</span>

<span class="sd">            Top-level :py:meth:`primary` is similar to :py:meth:`method`.</span>
<span class="sd">            Each of the individual rules then works with a tree instead of a child of the</span>
<span class="sd">            primary tree.</span>

<span class="sd">        This includes function-like macros: ``has()`` and ``dyn()``.</span>
<span class="sd">        These are special cases and cannot be overridden.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result_value</span><span class="p">:</span> <span class="n">Result</span>
        <span class="n">name_token</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad primary node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">child</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span><span class="p">:</span>
            <span class="c1"># A literal value</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;paren_expr&quot;</span><span class="p">:</span>
            <span class="c1"># A &quot;(&quot; expr &quot;)&quot;</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;list_lit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Empty list</span>
                <span class="c1"># TODO: Refactor into type_eval()</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># exprlist to be packaged as List.</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result_value</span>

        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;map_lit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Empty mapping</span>
                <span class="c1"># TODO: Refactor into type_eval()</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># mapinits (a sequence of key-value tuples) to be packaged as a dict.</span>
                <span class="c1"># OR. An CELEvalError in case of ValueError caused by duplicate keys.</span>
                <span class="c1"># OR. An CELEvalError in case of TypeError cause by invalid key types.</span>
                <span class="c1"># TODO: Refactor into type_eval()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">result_value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                    <span class="n">result_value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                        <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                    <span class="n">result_value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                        <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span>
                    <span class="p">)</span>
            <span class="k">return</span> <span class="n">result_value</span>

        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;dot_ident&quot;</span><span class="p">,</span> <span class="s2">&quot;dot_ident_arg&quot;</span><span class="p">):</span>
            <span class="c1"># &quot;.&quot; IDENT [&quot;(&quot; [exprlist] &quot;)&quot;]</span>
            <span class="c1"># Leading &quot;.&quot; means the name is resolved in the root scope **only**.</span>
            <span class="c1"># No searching through alternative packages.</span>
            <span class="c1"># len(child) == 1 -- &quot;.&quot; IDENT</span>
            <span class="c1"># len(child) == 2 -- &quot;.&quot; IDENT &quot;(&quot; exprlist &quot;)&quot; -- TODO: Implement dot_ident_arg.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="n">name_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Should not be a Function, should only be a Result</span>
            <span class="c1"># TODO: implement dot_ident_arg using ``function_eval()``, which should match this code.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">Result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ident_value</span><span class="p">(</span><span class="n">name_token</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">root_scope</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                    <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">result_value</span>

        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;ident_arg&quot;</span><span class="p">:</span>
            <span class="c1"># IDENT [&quot;(&quot; [exprlist] &quot;)&quot;]</span>
            <span class="c1"># Can be a proper function or one of the function-like macros: &quot;has()&quot;, &quot;dyn()&quot;.</span>
            <span class="n">exprlist</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">name_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">exprlist</span> <span class="o">=</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;exprlist&quot;</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">name_token</span><span class="p">,</span> <span class="n">exprlist</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>  <span class="c1"># pragma: no cover</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad primary node&quot;</span><span class="p">,</span>
                    <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                    <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;has&quot;</span><span class="p">:</span>
                <span class="c1"># has() macro. True if the child expression is a member expression that evaluates.</span>
                <span class="c1"># False if the child expression is a member expression that cannot be evaluated.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">macro_has_eval</span><span class="p">(</span><span class="n">exprlist</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;dyn&quot;</span><span class="p">:</span>
                <span class="c1"># dyn() macro does nothing; it&#39;s for run-time type-checking.</span>
                <span class="n">dyn_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">exprlist</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">dyn_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Ordinary function() evaluation.</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">exprlist</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_eval</span><span class="p">(</span>
                    <span class="n">name_token</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="n">Iterable</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="n">values</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;ident&quot;</span><span class="p">:</span>
            <span class="c1"># IDENT -- simple identifier from the current activation.</span>
            <span class="n">name_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Should not be a Function.</span>
                <span class="c1"># Generally Result object (i.e., a variable)</span>
                <span class="c1"># Could be an Annotation object (i.e., a type) for protobuf messages</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ident_value</span><span class="p">(</span><span class="n">name_token</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;undeclared reference to &#39;</span><span class="si">{</span><span class="n">name_token</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(in activation &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>
                <span class="p">)</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result_value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad primary node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.literal">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.literal">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a literal from the token at the top of the parse tree.</span>

<span class="sd">        ..  todo:: Use type provider conversions from string to CEL type objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad literal node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">value_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result_value</span><span class="p">:</span> <span class="n">Result</span>
            <span class="k">if</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;FLOAT_LIT&quot;</span><span class="p">:</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">DoubleType</span><span class="p">(</span><span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;INT_LIT&quot;</span><span class="p">:</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;UINT_LIT&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;u&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;invalid unsigned int literal </span><span class="si">{</span><span class="n">value_token</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                        <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">UintType</span><span class="p">(</span><span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;MLSTRING_LIT&quot;</span><span class="p">,</span> <span class="s2">&quot;STRING_LIT&quot;</span><span class="p">):</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">celstr</span><span class="p">(</span><span class="n">value_token</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;BYTES_LIT&quot;</span><span class="p">:</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">celbytes</span><span class="p">(</span><span class="n">value_token</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;BOOL_LIT&quot;</span><span class="p">:</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span>
                    <span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;NULL_LIT&quot;</span><span class="p">:</span>
                <span class="n">result_value</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CELUnsupportedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: type not implemented&quot;</span><span class="p">,</span>
                    <span class="n">line</span><span class="o">=</span><span class="n">value_token</span><span class="o">.</span><span class="n">line</span> <span class="ow">or</span> <span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                    <span class="n">column</span><span class="o">=</span><span class="n">value_token</span><span class="o">.</span><span class="n">column</span> <span class="ow">or</span> <span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">result_value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result_value</span></div>


<div class="viewcode-block" id="Evaluator.exprlist">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.exprlist">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">exprlist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        exprlist       : expr (&quot;,&quot; expr)*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># There are no CELEvalError values in the result, so we can narrow the domain.</span>
        <span class="n">result_value</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="n">values</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result_value</span></div>


<div class="viewcode-block" id="Evaluator.fieldinits">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.fieldinits">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fieldinits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        fieldinits     : IDENT &quot;:&quot; expr (&quot;,&quot; IDENT &quot;:&quot; expr)*</span>

<span class="sd">        The even items, children[0::2] are identifiers, nothing to evaluate.</span>
<span class="sd">        The odd items, childnre[1::2] are expressions.</span>

<span class="sd">        This creates a mapping, used by the :meth:`member_object` method to create</span>
<span class="sd">        and populate a protobuf object. Duplicate names are an error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">]],</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">ident_node</span><span class="p">,</span> <span class="n">expr_node</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="n">ident</span> <span class="o">=</span> <span class="n">ident_node</span><span class="o">.</span><span class="n">value</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">expr_node</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ident</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Duplicate field label </span><span class="si">{</span><span class="n">ident</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fields</span><span class="p">[</span><span class="n">ident</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MessageType</span><span class="p">(</span><span class="o">**</span><span class="n">fields</span><span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.mapinits">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Evaluator.mapinits">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mapinits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        mapinits       : expr &quot;:&quot; expr (&quot;,&quot; expr &quot;:&quot; expr)*</span>

<span class="sd">        Extract the key expr&#39;s and value expr&#39;s to a list of pairs.</span>
<span class="sd">        This raises an exception on a duplicate key.</span>

<span class="sd">        .. TODO:: CEL question.</span>

<span class="sd">            Is ``{&#39;a&#39;: 1, &#39;b&#39;: 2/0}[&#39;a&#39;]`` a meaningful result in CEL?</span>
<span class="sd">            Or is this an error because the entire member object is erroneous?</span>

<span class="sd">        ..  TODO:: Refactor to use MapType([(key, value),...]) init, which checks for duplicates.</span>

<span class="sd">            This simplifies to ``celpy.celtypes.MapType(pairs)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result_value</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">()</span>

        <span class="c1"># Not sure if this cast is sensible. Should a CELEvalError propagate up from the</span>
        <span class="c1"># sub-expressions? See the error check in :py:func:`exprlist`.</span>
        <span class="n">keys_values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys_values</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">keys_values</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result_value</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Duplicate key </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">result_value</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">result_value</span></div>
</div>



<span class="c1"># GLOBAL activation used by Transpiled code.</span>
<span class="c1"># This slightly simplifies the exception handling, by using a 1-argument function</span>
<span class="c1"># to compute a Value or a CELEvalError.</span>

<span class="n">the_activation</span><span class="p">:</span> <span class="n">Activation</span>


<div class="viewcode-block" id="result">
<a class="viewcode-back" href="../../api.html#celpy.__init__.result">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">result</span><span class="p">(</span><span class="n">activation</span><span class="p">:</span> <span class="n">Activation</span><span class="p">,</span> <span class="n">cel_expr</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Activation</span><span class="p">],</span> <span class="n">Result</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements &quot;checked exception&quot; handling for CEL expressions transpiled to Python.</span>
<span class="sd">    An expression must be wrapped by a lambda.</span>
<span class="sd">    The lambda is evaluated by this function; a subset of Python exceptions become ``CELEvalError`` objects.</span>

<span class="sd">    &gt;&gt;&gt; some_activation = Activation()</span>

<span class="sd">    Within the CEL transpiled code, we can now use code like this...</span>

<span class="sd">    &gt;&gt;&gt; expr = lambda activation: 355 / 0</span>
<span class="sd">    &gt;&gt;&gt; result(some_activation, expr)</span>
<span class="sd">    CELEvalError(*(&#39;divide by zero&#39;, &lt;class &#39;ZeroDivisionError&#39;&gt;, (&#39;division by zero&#39;,)))</span>

<span class="sd">    The exception becomes an object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">value</span><span class="p">:</span> <span class="n">Result</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">cel_expr</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span>
        <span class="ne">ValueError</span><span class="p">,</span>
        <span class="ne">KeyError</span><span class="p">,</span>
        <span class="ne">TypeError</span><span class="p">,</span>
        <span class="ne">ZeroDivisionError</span><span class="p">,</span>
        <span class="ne">OverflowError</span><span class="p">,</span>
        <span class="ne">IndexError</span><span class="p">,</span>
        <span class="ne">NameError</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
        <span class="n">ex_message</span> <span class="o">=</span> <span class="p">{</span>
            <span class="ne">ValueError</span><span class="p">:</span> <span class="s2">&quot;return error for overflow&quot;</span><span class="p">,</span>
            <span class="ne">KeyError</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;no such member in mapping: </span><span class="si">{</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="ne">TypeError</span><span class="p">:</span> <span class="s2">&quot;no such overload&quot;</span><span class="p">,</span>
            <span class="ne">ZeroDivisionError</span><span class="p">:</span> <span class="s2">&quot;divide by zero&quot;</span><span class="p">,</span>
            <span class="ne">OverflowError</span><span class="p">:</span> <span class="s2">&quot;return error for overflow&quot;</span><span class="p">,</span>
            <span class="ne">IndexError</span><span class="p">:</span> <span class="s2">&quot;invalid_argument&quot;</span><span class="p">,</span>
            <span class="ne">UnicodeDecodeError</span><span class="p">:</span> <span class="s2">&quot;invalid UTF-8&quot;</span><span class="p">,</span>
            <span class="ne">NameError</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;undeclared reference to </span><span class="si">{</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">!r}</span><span class="s2"> (in container </span><span class="si">{</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="si">!r}</span><span class="s2">)&quot;</span><span class="p">,</span>
        <span class="p">}[</span><span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">]</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">ex_message</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
        <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;result = </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span></div>



<div class="viewcode-block" id="macro_map">
<a class="viewcode-back" href="../../api.html#celpy.__init__.macro_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">macro_map</span><span class="p">(</span>
    <span class="n">activation</span><span class="p">:</span> <span class="n">Activation</span><span class="p">,</span>
    <span class="n">bind_variable</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">cel_expr</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Activation</span><span class="p">],</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span>
    <span class="n">cel_gen</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Activation</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Activation</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The results of a source.map(v, expr) macro: a list of values.&quot;&quot;&quot;</span>
    <span class="n">activations</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">activation</span><span class="o">.</span><span class="n">nested_activation</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="p">{</span><span class="n">bind_variable</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">_value</span><span class="p">)})</span>
        <span class="k">for</span> <span class="n">_value</span> <span class="ow">in</span> <span class="n">cel_gen</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">cel_expr</span><span class="p">,</span> <span class="n">activations</span><span class="p">))</span></div>



<div class="viewcode-block" id="macro_filter">
<a class="viewcode-back" href="../../api.html#celpy.__init__.macro_filter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">macro_filter</span><span class="p">(</span>
    <span class="n">activation</span><span class="p">:</span> <span class="n">Activation</span><span class="p">,</span>
    <span class="n">bind_variable</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">cel_expr</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Activation</span><span class="p">],</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span>
    <span class="n">cel_gen</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Activation</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Activation</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The results of a source.filter(v, expr) macro: a list of values.&quot;&quot;&quot;</span>
    <span class="n">r</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">cel_gen</span><span class="p">(</span><span class="n">activation</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">cel_expr</span><span class="p">(</span>
            <span class="n">activation</span><span class="o">.</span><span class="n">nested_activation</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="p">{</span><span class="n">bind_variable</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">value</span><span class="p">)})</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">r</span><span class="p">))</span></div>



<div class="viewcode-block" id="macro_exists_one">
<a class="viewcode-back" href="../../api.html#celpy.__init__.macro_exists_one">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">macro_exists_one</span><span class="p">(</span>
    <span class="n">activation</span><span class="p">:</span> <span class="n">Activation</span><span class="p">,</span>
    <span class="n">bind_variable</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">cel_expr</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Activation</span><span class="p">],</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span>
    <span class="n">cel_gen</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Activation</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Activation</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The results of a source.exists_one(v, expr) macro: a list of values.</span>

<span class="sd">    Note the short-circuit concept.</span>
<span class="sd">    Count the True; Break on an Exception</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">activations</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">activation</span><span class="o">.</span><span class="n">nested_activation</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="p">{</span><span class="n">bind_variable</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">_value</span><span class="p">)})</span>
        <span class="k">for</span> <span class="n">_value</span> <span class="ow">in</span> <span class="n">cel_gen</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">cel_expr</span><span class="p">,</span> <span class="n">activations</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="macro_exists">
<a class="viewcode-back" href="../../api.html#celpy.__init__.macro_exists">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">macro_exists</span><span class="p">(</span>
    <span class="n">activation</span><span class="p">:</span> <span class="n">Activation</span><span class="p">,</span>
    <span class="n">bind_variable</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">cel_expr</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Activation</span><span class="p">],</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span>
    <span class="n">cel_gen</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Activation</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Activation</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The results of a source.exists(v, expr) macro: a list of values.&quot;&quot;&quot;</span>
    <span class="n">activations</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">activation</span><span class="o">.</span><span class="n">nested_activation</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="p">{</span><span class="n">bind_variable</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">_value</span><span class="p">)})</span>
        <span class="k">for</span> <span class="n">_value</span> <span class="ow">in</span> <span class="n">cel_gen</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span>
        <span class="n">reduce</span><span class="p">(</span>
            <span class="n">cast</span><span class="p">(</span>
                <span class="n">Callable</span><span class="p">[[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">,</span> <span class="n">Result</span><span class="p">],</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">],</span>
                <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_or</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="p">(</span><span class="n">result</span><span class="p">(</span><span class="n">act</span><span class="p">,</span> <span class="n">cel_expr</span><span class="p">)</span> <span class="k">for</span> <span class="n">act</span> <span class="ow">in</span> <span class="n">activations</span><span class="p">),</span>
            <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="kc">False</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="macro_all">
<a class="viewcode-back" href="../../api.html#celpy.__init__.macro_all">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">macro_all</span><span class="p">(</span>
    <span class="n">activation</span><span class="p">:</span> <span class="n">Activation</span><span class="p">,</span>
    <span class="n">bind_variable</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">cel_expr</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Activation</span><span class="p">],</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span>
    <span class="n">cel_gen</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Activation</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Activation</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The results of a source.all(v, expr) macro: a list of values.&quot;&quot;&quot;</span>
    <span class="n">activations</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">activation</span><span class="o">.</span><span class="n">nested_activation</span><span class="p">(</span><span class="nb">vars</span><span class="o">=</span><span class="p">{</span><span class="n">bind_variable</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">_value</span><span class="p">)})</span>
        <span class="k">for</span> <span class="n">_value</span> <span class="ow">in</span> <span class="n">cel_gen</span><span class="p">(</span><span class="n">activation</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span>
        <span class="n">reduce</span><span class="p">(</span>
            <span class="n">cast</span><span class="p">(</span>
                <span class="n">Callable</span><span class="p">[[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">,</span> <span class="n">Result</span><span class="p">],</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">],</span>
                <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_and</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="p">(</span><span class="n">result</span><span class="p">(</span><span class="n">act</span><span class="p">,</span> <span class="n">cel_expr</span><span class="p">)</span> <span class="k">for</span> <span class="n">act</span> <span class="ow">in</span> <span class="n">activations</span><span class="p">),</span>
            <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="TranspilerTree">
<a class="viewcode-back" href="../../api.html#celpy.__init__.TranspilerTree">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TranspilerTree</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">):</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">children</span><span class="p">:</span> <span class="s2">&quot;Sequence[Union[lark.Token, TranspilerTree]]&quot;</span>  <span class="c1"># type: ignore[assignment]</span>

<div class="viewcode-block" id="TranspilerTree.__init__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.TranspilerTree.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">children</span><span class="p">:</span> <span class="s2">&quot;Sequence[Union[lark.Token, TranspilerTree]]&quot;</span><span class="p">,</span>
        <span class="n">meta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">Meta</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span>  <span class="c1"># type: ignore [arg-type]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Updated by visitor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transpiled</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;ex_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">expr_number</span><span class="si">}</span><span class="s2">(activation)&quot;</span>  <span class="c1"># Default, often replaced.</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checked_exception</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="nb">tuple</span><span class="p">[</span><span class="n">Template</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TranspilerTree</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]],</span> <span class="kc">None</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Optional</span></div>
</div>



<div class="viewcode-block" id="Transpiler">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Transpiler">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Transpiler</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transpile the CEL construct(s) to Python functions.</span>
<span class="sd">    This is a **Facade** that wraps two visitor subclasses to do two phases</span>
<span class="sd">    of transpilation.</span>

<span class="sd">    The resulting Python code can be used with ``compile()`` and ``exec()``.</span>

<span class="sd">    :Phase I:</span>
<span class="sd">        The easy transpilation.</span>
<span class="sd">        It builds simple text expressions for each node of the AST.</span>
<span class="sd">        This sets aside exception-checking code including short-circuit logic operators and macros.</span>
<span class="sd">        This decorates the AST with transpiled Python where possible.</span>
<span class="sd">        It can also decorate with ``Template`` objects that require text from children.</span>

<span class="sd">    :Phase II:</span>
<span class="sd">        Collects a sequence of statements.</span>
<span class="sd">        All of the exception-checking for short-circuit logic operators and macros is packaged as lambdas</span>
<span class="sd">        that may (or may not) be evaluated.</span>

<span class="sd">    Ideally, there could be a ``Transpiler`` ABC, and the ``PythonTranspiler`` defined as a subclass.</span>
<span class="sd">    Pragmatically, we can&#39;t see any other sensible transpilation.</span>

<span class="sd">    ..  rubric:: Exception Checking</span>

<span class="sd">    To handle ``2 / 0 || true``, the ``||``, ``&amp;&amp;``, and ``?:`` operators</span>
<span class="sd">    the generated code creates lambdas to avoid execution where possible.</span>
<span class="sd">    An alternative is a Monad-like structure to bottle up an exception, silencing it if it&#39;s unused.</span>

<span class="sd">    ..  rubric:: Identifiers</span>

<span class="sd">    Identifiers have three meanings:</span>

<span class="sd">    -   An object. This is either a variable provided in an ``Activation`` or a function provided</span>
<span class="sd">        when building an execution. Objects also have type annotations.</span>

<span class="sd">    -   A type annotation without an object. This can used to build protobuf messages.</span>

<span class="sd">    -   A macro name. The ``member_dot_arg`` construct (e.g., ``member.map(v, expr)``) may have a macro instead of a method.</span>
<span class="sd">        Plus the ``ident_arg`` construct may be a ``dyn()`` or ``has()`` macro instead of a function</span>

<span class="sd">    Other than macros, a name maps to an ``Referent`` instance.</span>
<span class="sd">    This will have an annotation and -- perhaps -- an associated object.</span>

<span class="sd">    ..  important MACROS ARE SPECIAL</span>

<span class="sd">        They aren&#39;t simple functions.</span>

<span class="sd">        The macros do not simply visit their children to perform evaluation.</span>

<span class="sd">        There&#39;s a bind variable and a function with the bind variable.</span>
<span class="sd">        This isn&#39;t **trivially** moved from expression stack to statements.</span>

<span class="sd">    There are two functions that are macro-like:</span>

<span class="sd">    - ``dyn()`` does effectively nothing.</span>
<span class="sd">      It visits its children, but also provides progressive type resolution</span>
<span class="sd">      through detailed type annotation of the AST.</span>

<span class="sd">    - ``has()`` attempts to visit the child and does a boolean transformation</span>
<span class="sd">      on the resulting exception or value.</span>
<span class="sd">      This is a macro because it doesn&#39;t raise the exception for a missing</span>
<span class="sd">      member item reference, but instead maps any exception to ``False``.</span>
<span class="sd">      It doesn&#39;t return the value found for a member item reference; instead, it maps</span>
<span class="sd">      successfully finding a member to ``True``.</span>

<span class="sd">    The member and expression list of a macro are transformed into lambdas for use by</span>
<span class="sd">    special ``macro_{name}`` functions. These functions provided the necessary generator</span>
<span class="sd">    expression to provide CEL semantics.</span>

<span class="sd">    Names have nested paths. For example, ``a.b.c`` is a mapping ``a``, that contains a mapping, ``b``,</span>
<span class="sd">    that contains a name ``c``.</span>

<span class="sd">    The :py:meth:`member` method implements the macro evaluation behavior.</span>
<span class="sd">    It does not **always** trivially descend into the children.</span>
<span class="sd">    In the case of macros, the member evaluates one child tree in the presence</span>
<span class="sd">    of values from another child tree using specific variable binding in a kind</span>
<span class="sd">    of stack frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;celpy.Transpiler&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Transpiler.__init__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Transpiler.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ast</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">,</span>
        <span class="n">activation</span><span class="p">:</span> <span class="n">Activation</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the Transpiler for an AST with specific variables and functions.</span>

<span class="sd">        :param ast: The AST to transpile.</span>
<span class="sd">        :param activation: An activation with functions and types to use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ast</span> <span class="o">=</span> <span class="n">ast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_activation</span> <span class="o">=</span> <span class="n">activation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_activation</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Transpiler activation: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span></div>

        <span class="c1"># self.logger.debug(&quot;functions: %r&quot;, self.functions)  # Refactor ``self.functions`` into an Activation</span>

<div class="viewcode-block" id="Transpiler.transpile">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Transpiler.transpile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transpile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Two-phase transpilation.</span>

<span class="sd">        1. Decorate AST with the most constructs.</span>
<span class="sd">        2. Expand into statements for lambdas that wrap checked exceptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phase_1</span> <span class="o">=</span> <span class="n">Phase1Transpiler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">phase_1</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

        <span class="n">phase_2</span> <span class="o">=</span> <span class="n">Phase2Transpiler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">phase_2</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

        <span class="n">statements</span> <span class="o">=</span> <span class="n">phase_2</span><span class="o">.</span><span class="n">statements</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

        <span class="c1"># The complete sequence of statements and the code object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">statements</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">executable_code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_text</span><span class="p">,</span> <span class="s2">&quot;&lt;string&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Transpiler.evaluate">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Transpiler.evaluate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">context</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_activation</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">load_values</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_activation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Activation: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span>

        <span class="c1"># Global for the top-level ``CEL = result(base_activation, ...)`` statement.</span>
        <span class="n">evaluation_globals</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">celpy</span><span class="o">.</span><span class="n">evaluation</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="vm">__globals__</span>
        <span class="p">)</span>  <span class="c1"># the ``evaluation`` moodule</span>
        <span class="n">evaluation_globals</span><span class="p">[</span><span class="s2">&quot;base_activation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">exec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">executable_code</span><span class="p">,</span> <span class="n">evaluation_globals</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">evaluation_globals</span><span class="p">[</span><span class="s2">&quot;CEL&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">value</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="c1"># A Python problem during ``exec()``</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Internal error: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="s2">&quot;evaluation error&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">ex</span><span class="p">),</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Phase1Transpiler">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Phase1Transpiler</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">visitors</span><span class="o">.</span><span class="n">Visitor_Recursive</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorate all nodes with transpiled Python code, where possible.</span>
<span class="sd">    For short-circuit operators or macros, where a &quot;checked exception&quot; is required,</span>
<span class="sd">    a simple ``ex_{n}`` name is present, and separate statements are provided as</span>
<span class="sd">    a decoration to handle the more complicated cases.</span>

<span class="sd">    Each construct has an associated ``Template``.</span>
<span class="sd">    For the simple cases, the transpiled value is the entire expression.</span>

<span class="sd">    &gt;&gt;&gt; from unittest.mock import Mock</span>
<span class="sd">    &gt;&gt;&gt; source = &quot;7 * (3 + 3)&quot;</span>
<span class="sd">    &gt;&gt;&gt; parser = celpy.CELParser()</span>
<span class="sd">    &gt;&gt;&gt; tree = parser.parse(source)</span>
<span class="sd">    &gt;&gt;&gt; tp = Phase1Transpiler(Mock(base_activation=celpy.Activation()))</span>
<span class="sd">    &gt;&gt;&gt; _ = tp.visit(tree)</span>
<span class="sd">    &gt;&gt;&gt; tree.transpiled</span>
<span class="sd">    &#39;operator.mul(celpy.celtypes.IntType(7), operator.add(celpy.celtypes.IntType(3), celpy.celtypes.IntType(3)))&#39;</span>

<span class="sd">    Some constructs wrap macros or short-circuit logic, and require a more sophisticated execution.</span>
<span class="sd">    There will be &quot;checked exceptions&quot;, returned as values.</span>
<span class="sd">    This requires statements with lambdas that can be wrapped by the ``result()`` function.</span>

<span class="sd">    The ``Phase2Transpiler`` does this transformation from expressions to a sequence of statements.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Phase1Transpiler.__init__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facade</span><span class="p">:</span> <span class="n">Transpiler</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">facade</span> <span class="o">=</span> <span class="n">facade</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">facade</span><span class="o">.</span><span class="n">base_activation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr_number</span> <span class="o">=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Phase1Transpiler.visit">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.visit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TranspilerTree</span><span class="p">:</span>  <span class="c1"># type: ignore[override]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the decorations for each node.&quot;&quot;&quot;</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_number</span>
        <span class="c1"># tree.transpiled = f&quot;ex_{tree.expr_number}(activation)&quot;  # Default, will be replaced.</span>
        <span class="c1"># tree.checked_exception: Union[str, None] = None  # Optional</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr_number</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>  <span class="c1"># type: ignore[return-value]</span></div>


<div class="viewcode-block" id="Phase1Transpiler.func_name">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.func_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">func_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide a transpiler-friendly name for the function.</span>

<span class="sd">        Some internally-defined functions appear to come from ``_operator`` module.</span>
<span class="sd">        We need to rename some ``celpy`` functions to be from ``operator``.</span>

<span class="sd">        Some functions -- specifically lt, le, gt, ge, eq, ne -- are wrapped ``boolean(operator.f)``</span>
<span class="sd">        obscuring their name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># func = self.functions[label]    # Refactor ``self.functions`` into an Activation</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_function</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;CELEvalError(&#39;unbound function&#39;, KeyError, (</span><span class="si">{</span><span class="n">label</span><span class="si">!r}</span><span class="s2">,))&quot;</span>
        <span class="n">module</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_operator&quot;</span><span class="p">:</span> <span class="s2">&quot;operator&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">module</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="Phase1Transpiler.expr">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.expr">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        expr           : conditionalor [&quot;?&quot; conditionalor &quot;:&quot; expr]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                <span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                # expr:</span>
<span class="s2">                ex_$</span><span class="si">{n}</span><span class="s2">_c = lambda activation: $</span><span class="si">{cond}</span>
<span class="s2">                ex_$</span><span class="si">{n}</span><span class="s2">_l = lambda activation: $</span><span class="si">{left}</span>
<span class="s2">                ex_$</span><span class="si">{n}</span><span class="s2">_r = lambda activation: $</span><span class="si">{rght}</span>
<span class="s2">                ex_$</span><span class="si">{n}</span><span class="s2"> = lambda activation: $</span><span class="si">{func_name}</span><span class="s2">(celpy.evaluation.result(activation, ex_$</span><span class="si">{n}</span><span class="s2">_c), celpy.evaluation.result(activation, ex_$</span><span class="si">{n}</span><span class="s2">_l), celpy.evaluation.result(activation, ex_$</span><span class="si">{n}</span><span class="s2">_r))&quot;&quot;&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">checked_exception</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">template</span><span class="p">,</span>
                <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">n</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span><span class="p">),</span>
                    <span class="n">func_name</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">(</span><span class="s2">&quot;_?_:_&quot;</span><span class="p">),</span>
                    <span class="n">cond</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                    <span class="n">left</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                    <span class="n">rght</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;ex_</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span><span class="si">}</span><span class="s2">(activation)&quot;</span></div>


<div class="viewcode-block" id="Phase1Transpiler.conditionalor">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.conditionalor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">conditionalor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        conditionalor  : [conditionalor &quot;||&quot;] conditionaland</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                <span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                # conditionalor:</span>
<span class="s2">                ex_$</span><span class="si">{n}</span><span class="s2">_l = lambda activation: $</span><span class="si">{left}</span>
<span class="s2">                ex_$</span><span class="si">{n}</span><span class="s2">_r = lambda activation: $</span><span class="si">{rght}</span>
<span class="s2">                ex_$</span><span class="si">{n}</span><span class="s2"> = lambda activation: $</span><span class="si">{func_name}</span><span class="s2">(celpy.evaluation.result(activation, ex_$</span><span class="si">{n}</span><span class="s2">_l), celpy.evaluation.result(activation, ex_$</span><span class="si">{n}</span><span class="s2">_r))&quot;&quot;&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">checked_exception</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">template</span><span class="p">,</span>
                <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">n</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span><span class="p">),</span>
                    <span class="n">func_name</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">(</span><span class="s2">&quot;_||_&quot;</span><span class="p">),</span>
                    <span class="n">left</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                    <span class="n">rght</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;ex_</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span><span class="si">}</span><span class="s2">(activation)&quot;</span></div>


<div class="viewcode-block" id="Phase1Transpiler.conditionaland">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.conditionaland">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">conditionaland</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        conditionaland : [conditionaland &quot;&amp;&amp;&quot;] relation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                <span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                # conditionaland:</span>
<span class="s2">                ex_$</span><span class="si">{n}</span><span class="s2">_l = lambda activation: $</span><span class="si">{left}</span>
<span class="s2">                ex_$</span><span class="si">{n}</span><span class="s2">_r = lambda activation: $</span><span class="si">{rght}</span>
<span class="s2">                ex_$</span><span class="si">{n}</span><span class="s2"> = lambda activation: $</span><span class="si">{func_name}</span><span class="s2">(celpy.evaluation.result(activation, ex_$</span><span class="si">{n}</span><span class="s2">_l), celpy.evaluation.result(activation, ex_$</span><span class="si">{n}</span><span class="s2">_r))&quot;&quot;&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">checked_exception</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">template</span><span class="p">,</span>
                <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">n</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span><span class="p">),</span>
                    <span class="n">func_name</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">(</span><span class="s2">&quot;_&amp;&amp;_&quot;</span><span class="p">),</span>
                    <span class="n">left</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                    <span class="n">rght</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;ex_</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span><span class="si">}</span><span class="s2">(activation)&quot;</span></div>


<div class="viewcode-block" id="Phase1Transpiler.relation">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.relation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">relation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        relation       : [relation_lt | relation_le | relation_ge | relation_gt</span>
<span class="sd">                       | relation_eq | relation_ne | relation_in] addition</span>

<span class="sd">        relation_lt    : relation &quot;&lt;&quot;</span>
<span class="sd">        relation_le    : relation &quot;&lt;=&quot;</span>
<span class="sd">        relation_gt    : relation &quot;&gt;&quot;</span>
<span class="sd">        relation_ge    : relation &quot;&gt;=&quot;</span>
<span class="sd">        relation_eq    : relation &quot;==&quot;</span>
<span class="sd">        relation_ne    : relation &quot;!=&quot;</span>
<span class="sd">        relation_in    : relation &quot;in&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">left_op</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span>
            <span class="p">)</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;relation_lt&quot;</span><span class="p">:</span> <span class="s2">&quot;_&lt;_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_le&quot;</span><span class="p">:</span> <span class="s2">&quot;_&lt;=_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_ge&quot;</span><span class="p">:</span> <span class="s2">&quot;_&gt;=_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_gt&quot;</span><span class="p">:</span> <span class="s2">&quot;_&gt;_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_eq&quot;</span><span class="p">:</span> <span class="s2">&quot;_==_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_ne&quot;</span><span class="p">:</span> <span class="s2">&quot;_!=_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_in&quot;</span><span class="p">:</span> <span class="s2">&quot;_in_&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="n">func_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{func_name}</span><span class="s2">($</span><span class="si">{left}</span><span class="s2">, $</span><span class="si">{right}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
                <span class="n">func_name</span><span class="o">=</span><span class="n">func_name</span><span class="p">,</span>
                <span class="n">left</span><span class="o">=</span><span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">left_op</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                <span class="n">right</span><span class="o">=</span><span class="n">right_tree</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.addition">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.addition">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">addition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        addition       : [addition_add | addition_sub] multiplication</span>

<span class="sd">        addition_add   : addition &quot;+&quot;</span>
<span class="sd">        addition_sub   : addition &quot;-&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">left_op</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span>
            <span class="p">)</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;addition_add&quot;</span><span class="p">:</span> <span class="s2">&quot;_+_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;addition_sub&quot;</span><span class="p">:</span> <span class="s2">&quot;_-_&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="n">func_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{func_name}</span><span class="s2">($</span><span class="si">{left}</span><span class="s2">, $</span><span class="si">{right}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
                <span class="n">func_name</span><span class="o">=</span><span class="n">func_name</span><span class="p">,</span>
                <span class="n">left</span><span class="o">=</span><span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">left_op</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                <span class="n">right</span><span class="o">=</span><span class="n">right_tree</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.multiplication">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.multiplication">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">multiplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        multiplication : [multiplication_mul | multiplication_div | multiplication_mod] unary</span>

<span class="sd">        multiplication_mul : multiplication &quot;*&quot;</span>
<span class="sd">        multiplication_div : multiplication &quot;/&quot;</span>
<span class="sd">        multiplication_mod : multiplication &quot;%&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{func_name}</span><span class="s2">(*$</span><span class="si">{children}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">left_op</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span>
            <span class="p">)</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;multiplication_mul&quot;</span><span class="p">:</span> <span class="s2">&quot;_*_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;multiplication_div&quot;</span><span class="p">:</span> <span class="s2">&quot;_/_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;multiplication_mod&quot;</span><span class="p">:</span> <span class="s2">&quot;_%_&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="n">func_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{func_name}</span><span class="s2">($</span><span class="si">{left}</span><span class="s2">, $</span><span class="si">{right}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
                <span class="n">func_name</span><span class="o">=</span><span class="n">func_name</span><span class="p">,</span>
                <span class="n">left</span><span class="o">=</span><span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">left_op</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                <span class="n">right</span><span class="o">=</span><span class="n">right_tree</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.unary">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.unary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        unary          : [unary_not | unary_neg] member</span>

<span class="sd">        unary_not      : &quot;!&quot;</span>
<span class="sd">        unary_neg      : &quot;-&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{func_name}</span><span class="s2">($</span><span class="si">{children}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">op_tree</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span>
            <span class="p">)</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;unary_not&quot;</span><span class="p">:</span> <span class="s2">&quot;!_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;unary_neg&quot;</span><span class="p">:</span> <span class="s2">&quot;-_&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">op_tree</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="n">func_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">right_tree</span><span class="o">.</span><span class="n">transpiled</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
                <span class="n">func_name</span><span class="o">=</span><span class="n">func_name</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="n">children</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.member">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.member">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member         : member_dot | member_dot_arg | member_item | member_object | primary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span></div>


<div class="viewcode-block" id="Phase1Transpiler.member_dot">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.member_dot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">member_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member_dot     : member &quot;.&quot; IDENT</span>

<span class="sd">        ..  important::</span>

<span class="sd">            The ``member`` can be any of a variety of objects:</span>

<span class="sd">            -   ``NameContainer(Dict[str, Referent])``</span>

<span class="sd">            -   ``Activation``</span>

<span class="sd">            -   ``MapType(Dict[Value, Value])``</span>

<span class="sd">            -   ``MessageType(MapType)``</span>

<span class="sd">            All of which define a ``get()`` method.</span>
<span class="sd">            The nuance is the ``NameContainer`` is also a Python ``dict`` and there&#39;s an</span>
<span class="sd">            overload issue between that ``get()`` and other ``get()`` definitions.</span>

<span class="sd">        ..  todo:: Define a new get_name(member, &#39;name&#39;) function do this, avoiding the ``get()`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">member_tree</span><span class="p">,</span> <span class="n">property_name_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">Tuple</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span>
        <span class="p">)</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{left}</span><span class="s2">.get(&#39;$</span><span class="si">{right}</span><span class="s2">&#39;)&quot;</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
            <span class="n">left</span><span class="o">=</span><span class="n">member_tree</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">property_name_token</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.member_dot_arg">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.member_dot_arg">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">member_dot_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member_dot_arg : member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>

<span class="sd">        Two flavors: macro and non-macro.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exprlist</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">member_tree</span><span class="p">,</span> <span class="n">property_name_token</span><span class="p">,</span> <span class="n">exprlist</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># len(tree.children) == 2, no [exprlist].</span>
            <span class="n">member_tree</span><span class="p">,</span> <span class="n">property_name_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span>
            <span class="p">)</span>
            <span class="n">exprlist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">property_name_token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">{</span>
            <span class="s2">&quot;map&quot;</span><span class="p">,</span>
            <span class="s2">&quot;filter&quot;</span><span class="p">,</span>
            <span class="s2">&quot;all&quot;</span><span class="p">,</span>
            <span class="s2">&quot;exists&quot;</span><span class="p">,</span>
            <span class="s2">&quot;exists_one&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reduce&quot;</span><span class="p">,</span>
            <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="p">}:</span>
            <span class="c1"># Macro. Defer to Phase II.</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                <span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                    # member_dot_arg $</span><span class="si">{macro}</span><span class="s2">:</span>
<span class="s2">                    ex_$</span><span class="si">{n}</span><span class="s2">_l = lambda activation: $</span><span class="si">{member}</span>
<span class="s2">                    ex_$</span><span class="si">{n}</span><span class="s2">_x = lambda activation: $</span><span class="si">{expr}</span>
<span class="s2">                    ex_$</span><span class="si">{n}</span><span class="s2"> = lambda activation: celpy.evaluation.macro_$</span><span class="si">{macro}</span><span class="s2">(activation, &#39;$</span><span class="si">{bind_variable}</span><span class="s2">&#39;, ex_$</span><span class="si">{n}</span><span class="s2">_x, ex_$</span><span class="si">{n}</span><span class="s2">_l)</span>
<span class="s2">                    &quot;&quot;&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># Hackery. Undo the transpiling of the identifier and extract only the name.</span>
                <span class="n">context</span><span class="p">,</span> <span class="n">bind_variable</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">transpiled</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>  <span class="c1"># pragma: no cover</span>
                    <span class="s2">&quot;no bind variable in </span><span class="si">{property_name_token.value}</span><span class="s2"> macro&quot;</span><span class="p">,</span>
                    <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                    <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">tree</span><span class="o">.</span><span class="n">checked_exception</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">template</span><span class="p">,</span>
                <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">n</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span><span class="p">),</span>
                    <span class="n">macro</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">property_name_token</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">member</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span>
                        <span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                    <span class="n">bind_variable</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">bind_variable</span><span class="p">,</span>
                    <span class="n">expr</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span>
                        <span class="n">TranspilerTree</span><span class="p">,</span>
                        <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">transpiled</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
                    <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;ex_</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span><span class="si">}</span><span class="s2">(activation)&quot;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Non-macro method name.</span>
            <span class="k">if</span> <span class="n">exprlist</span><span class="p">:</span>
                <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{func_name}</span><span class="s2">($</span><span class="si">{left}</span><span class="s2">, $</span><span class="si">{right}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="n">func_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">(</span><span class="n">property_name_token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
                    <span class="n">func_name</span><span class="o">=</span><span class="n">func_name</span><span class="p">,</span>
                    <span class="n">left</span><span class="o">=</span><span class="n">member_tree</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                    <span class="n">right</span><span class="o">=</span><span class="n">exprlist</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{func_name}</span><span class="s2">($</span><span class="si">{left}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="n">func_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">(</span><span class="n">property_name_token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
                    <span class="n">func_name</span><span class="o">=</span><span class="n">func_name</span><span class="p">,</span>
                    <span class="n">left</span><span class="o">=</span><span class="n">member_tree</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.member_index">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.member_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">member_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member_item    : member &quot;[&quot; expr &quot;]&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{func_name}</span><span class="s2">($</span><span class="si">{member}</span><span class="s2">, $</span><span class="si">{expr}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">member</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">tuple</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">(</span><span class="s2">&quot;_[_]&quot;</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
            <span class="n">func_name</span><span class="o">=</span><span class="n">func_name</span><span class="p">,</span>
            <span class="n">member</span><span class="o">=</span><span class="n">member</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
            <span class="n">expr</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.member_object">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.member_object">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">member_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member_object  : member &quot;{&quot; [fieldinits] &quot;}&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{type_name}</span><span class="s2">([$</span><span class="si">{fieldinits}</span><span class="s2">])&quot;</span><span class="p">)</span>
        <span class="n">member</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">fieldinits</span><span class="p">:</span> <span class="nb">str</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">fieldinits</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fieldinits</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">type_name</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
            <span class="n">type_name</span><span class="o">=</span><span class="n">type_name</span><span class="p">,</span> <span class="n">fieldinits</span><span class="o">=</span><span class="n">fieldinits</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.primary">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.primary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">primary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        primary        : dot_ident_arg | dot_ident | ident_arg | ident</span>
<span class="sd">                       | paren_expr | list_lit | map_lit | literal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span></div>


<div class="viewcode-block" id="Phase1Transpiler.dot_ident_arg">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.dot_ident_arg">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dot_ident_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        dot_ident_arg  : &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;activation.resolve_variable(&#39;$</span><span class="si">{ident}</span><span class="s2">&#39;)($</span><span class="si">{exprlist}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">ident</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">exprlist</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exprlist</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">ident</span><span class="o">=</span><span class="n">ident</span><span class="p">,</span> <span class="n">exprlist</span><span class="o">=</span><span class="n">exprlist</span><span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.dot_ident">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.dot_ident">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dot_ident</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        dot_ident      : &quot;.&quot; IDENT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;activation.resolve_variable(&#39;$</span><span class="si">{ident}</span><span class="s2">&#39;)&quot;</span><span class="p">)</span>
        <span class="n">ident</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">value</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">ident</span><span class="o">=</span><span class="n">ident</span><span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.ident_arg">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.ident_arg">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ident_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ident_arg      : IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">exprlist</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exprlist</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;has&quot;</span><span class="p">,</span> <span class="s2">&quot;dyn&quot;</span><span class="p">}:</span>
            <span class="c1"># Macro-like has() or dyn()</span>
            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;dyn&quot;</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;has&quot;</span><span class="p">:</span>
                <span class="c1"># try to evaluate the exprlist expression</span>
                <span class="c1"># TODO: as macro_has() would be better...</span>
                <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                    <span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                    # ident_arg has:</span>
<span class="s2">                    ex_$</span><span class="si">{n}</span><span class="s2">_h = lambda activation: $</span><span class="si">{exprlist}</span>
<span class="s2">                    ex_$</span><span class="si">{n}</span><span class="s2"> = lambda activation: not isinstance(celpy.evaluation.result(activation, ex_$</span><span class="si">{n}</span><span class="s2">_h), CELEvalError)</span>
<span class="s2">                    &quot;&quot;&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">checked_exception</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">template</span><span class="p">,</span>
                    <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">n</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span><span class="p">),</span>
                        <span class="n">exprlist</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">cast</span><span class="p">(</span>
                            <span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">transpiled</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;ex_</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span><span class="si">}</span><span class="s2">(activation)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Other function</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;$</span><span class="si">{func_name}</span><span class="s2">($</span><span class="si">{exprlist}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">func_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">exprlist</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">TranspilerTree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">transpiled</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exprlist</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
                <span class="n">func_name</span><span class="o">=</span><span class="n">func_name</span><span class="p">,</span> <span class="n">exprlist</span><span class="o">=</span><span class="n">exprlist</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.ident">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.ident">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ident</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ident          : IDENT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;activation.$</span><span class="si">{ident}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
            <span class="n">ident</span><span class="o">=</span><span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.paren_expr">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.paren_expr">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">paren_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        paren_expr     : &quot;(&quot; expr &quot;)&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpiled</span></div>


<div class="viewcode-block" id="Phase1Transpiler.list_lit">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.list_lit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">list_lit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        list_lit       : &quot;[&quot; [exprlist] &quot;]&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">exprlist</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exprlist</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;celpy.celtypes.ListType([$</span><span class="si">{exprlist}</span><span class="s2">])&quot;</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">exprlist</span><span class="o">=</span><span class="n">exprlist</span><span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.map_lit">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.map_lit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">map_lit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        map_lit        : &quot;{&quot; [mapinits] &quot;}&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">mapinits</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpiled</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mapinits</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span><span class="s2">&quot;celpy.celtypes.MapType([$</span><span class="si">{mapinits}</span><span class="s2">])&quot;</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">mapinits</span><span class="o">=</span><span class="n">mapinits</span><span class="p">)</span></div>


<div class="viewcode-block" id="Phase1Transpiler.exprlist">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.exprlist">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">exprlist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        exprlist       : expr (&quot;,&quot; expr)*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exprs</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">c</span><span class="o">.</span><span class="n">transpiled</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">exprs</span></div>


<div class="viewcode-block" id="Phase1Transpiler.fieldinits">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.fieldinits">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fieldinits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        fieldinits     : IDENT &quot;:&quot; expr (&quot;,&quot; IDENT &quot;:&quot; expr)*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idents</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)[::</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">c</span><span class="o">.</span><span class="n">transpiled</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">idents</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">exprs</span><span class="p">),</span> <span class="s2">&quot;Invalid AST&quot;</span>
        <span class="n">items</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&#39;, </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idents</span><span class="p">,</span> <span class="n">exprs</span><span class="p">))</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">items</span></div>


<div class="viewcode-block" id="Phase1Transpiler.mapinits">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.mapinits">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mapinits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        mapinits       : expr &quot;:&quot; expr (&quot;,&quot; expr &quot;:&quot; expr)*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">c</span><span class="o">.</span><span class="n">transpiled</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)[::</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">c</span><span class="o">.</span><span class="n">transpiled</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TranspilerTree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">items</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">items</span></div>


<div class="viewcode-block" id="Phase1Transpiler.literal">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase1Transpiler.literal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        literal        : UINT_LIT | FLOAT_LIT | INT_LIT | MLSTRING_LIT | STRING_LIT | BYTES_LIT</span>
<span class="sd">               | BOOL_LIT | NULL_LIT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;FLOAT_LIT&quot;</span><span class="p">:</span>
            <span class="n">lit_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;celpy.celtypes.DoubleType(</span><span class="si">{</span><span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;INT_LIT&quot;</span><span class="p">:</span>
            <span class="n">lit_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;celpy.celtypes.IntType(</span><span class="si">{</span><span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;UINT_LIT&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;u&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;invalid unsigned int literal </span><span class="si">{</span><span class="n">value_token</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                    <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
                <span class="p">)</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">lit_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;celpy.celtypes.UintType(</span><span class="si">{</span><span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;MLSTRING_LIT&quot;</span><span class="p">,</span> <span class="s2">&quot;STRING_LIT&quot;</span><span class="p">):</span>
            <span class="n">lit_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;celpy.celtypes.</span><span class="si">{</span><span class="n">celstr</span><span class="p">(</span><span class="n">value_token</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;BYTES_LIT&quot;</span><span class="p">:</span>
            <span class="n">lit_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;celpy.celtypes.</span><span class="si">{</span><span class="n">celbytes</span><span class="p">(</span><span class="n">value_token</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;BOOL_LIT&quot;</span><span class="p">:</span>
            <span class="n">lit_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;celpy.celtypes.BoolType(</span><span class="si">{</span><span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">&#39;true&#39;</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;NULL_LIT&quot;</span><span class="p">:</span>
            <span class="n">lit_text</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>  <span class="c1"># Not celpy.celtypes.NullType() in transpiled code.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELUnsupportedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: type not implemented&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">value_token</span><span class="o">.</span><span class="n">line</span> <span class="ow">or</span> <span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">value_token</span><span class="o">.</span><span class="n">column</span> <span class="ow">or</span> <span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span> <span class="o">=</span> <span class="n">lit_text</span></div>
</div>



<div class="viewcode-block" id="Phase2Transpiler">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase2Transpiler">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Phase2Transpiler</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">visitors</span><span class="o">.</span><span class="n">Visitor_Recursive</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract any checked_exception evaluation statements that decorate the parse tree.</span>
<span class="sd">    Also, get the overall top-level expression, assigned to special variable, CEL.</span>

<span class="sd">    &gt;&gt;&gt; from unittest.mock import Mock</span>
<span class="sd">    &gt;&gt;&gt; from pprint import pprint</span>
<span class="sd">    &gt;&gt;&gt; source = &#39;[&quot;hello&quot;, &quot;world&quot;].map(x, x) == [&quot;hello&quot;, &quot;world&quot;]&#39;</span>
<span class="sd">    &gt;&gt;&gt; celpy.CELParser.CEL_PARSER = None</span>
<span class="sd">    &gt;&gt;&gt; parser = celpy.CELParser(tree_class=celpy.evaluation.TranspilerTree)</span>
<span class="sd">    &gt;&gt;&gt; tree = parser.parse(source)</span>
<span class="sd">    &gt;&gt;&gt; tp1 = Phase1Transpiler(Mock(base_activation=celpy.Activation()))</span>
<span class="sd">    &gt;&gt;&gt; _ = tp1.visit(tree)</span>
<span class="sd">    &gt;&gt;&gt; tp2 = Phase2Transpiler(Mock(base_activation=celpy.Activation()))</span>
<span class="sd">    &gt;&gt;&gt; _ = tp2.visit(tree)</span>
<span class="sd">    &gt;&gt;&gt; pprint(tp2.statements(tree), width=256)</span>
<span class="sd">    [&#39;# member_dot_arg map:&#39;,</span>
<span class="sd">     &quot;ex_10_l = lambda activation: celpy.celtypes.ListType([celpy.celtypes.StringType(&#39;hello&#39;), celpy.celtypes.StringType(&#39;world&#39;)])&quot;,</span>
<span class="sd">     &#39;ex_10_x = lambda activation: activation.x&#39;,</span>
<span class="sd">     &quot;ex_10 = lambda activation: celpy.evaluation.macro_map(activation, &#39;x&#39;, ex_10_x, ex_10_l)&quot;,</span>
<span class="sd">     &quot;CEL = celpy.evaluation.result(base_activation, lambda activation: celpy.evaluation.bool_eq(ex_10(activation), celpy.celtypes.ListType([celpy.celtypes.StringType(&#39;hello&#39;), celpy.celtypes.StringType(&#39;world&#39;)])))\\n&quot;]</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Phase2Transpiler.__init__">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase2Transpiler.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facade</span><span class="p">:</span> <span class="n">Transpiler</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">facade</span> <span class="o">=</span> <span class="n">facade</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_statements</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Phase2Transpiler.expr">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase2Transpiler.expr">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        expr           : conditionalor [&quot;?&quot; conditionalor &quot;:&quot; expr]</span>

<span class="sd">        All checked_exception structures are a tuple[Template, dict[str, Callable[[Tree], str]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">checked_exception</span><span class="p">:</span>
            <span class="n">template</span><span class="p">,</span> <span class="n">bindings</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">checked_exception</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_statements</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bindings</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
            <span class="p">)</span></div>


    <span class="n">conditionalor</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="n">conditionaland</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="n">member_dot_arg</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="n">ident_arg</span> <span class="o">=</span> <span class="n">expr</span>

<div class="viewcode-block" id="Phase2Transpiler.statements">
<a class="viewcode-back" href="../../api.html#celpy.__init__.Phase2Transpiler.statements">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">statements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">TranspilerTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends the final CEL = ... statement to the sequence of statements,</span>
<span class="sd">        and returns the transpiled code.</span>

<span class="sd">        Two patterns:</span>

<span class="sd">        1.  Top-most expr was a deferred template, and already is a lambda.</span>
<span class="sd">            It will be a string of the form ``&quot;ex_\\d+(activation)&quot;``.</span>

<span class="sd">        2.  Top-most expr was **not** a deferred template, and needs a lambda wrapper.</span>
<span class="sd">            It will **not** be a simple ``&quot;ex_\\d+&quot;`` reference.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expr_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^(ex_\d+)\(\w+\)$&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="o">:=</span> <span class="n">expr_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span><span class="p">):</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                <span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                CEL = celpy.evaluation.result(base_activation, $</span><span class="si">{lambda_name}</span><span class="s2">)</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">final</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span><span class="p">,</span> <span class="n">lambda_name</span><span class="o">=</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                <span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                CEL = celpy.evaluation.result(base_activation, lambda activation: $</span><span class="si">{expr}</span><span class="s2">)</span>
<span class="s2">            &quot;&quot;&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">final</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">substitute</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">expr_number</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">transpiled</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_statements</span> <span class="o">+</span> <span class="p">[</span><span class="n">final</span><span class="p">]</span></div>
</div>



<span class="n">CEL_ESCAPES_PAT</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">[abfnrtv</span><span class="se">\&quot;</span><span class="s2">&#39;</span><span class="se">\\\\</span><span class="s2">]|</span><span class="se">\\\\\\</span><span class="s2">d</span><span class="si">{3}</span><span class="s2">|</span><span class="se">\\\\</span><span class="s2">x[0-9a-fA-F]</span><span class="si">{2}</span><span class="s2">|</span><span class="se">\\\\</span><span class="s2">u[0-9a-fA-F]</span><span class="si">{4}</span><span class="s2">|</span><span class="se">\\\\</span><span class="s2">U[0-9a-fA-F]</span><span class="si">{8}</span><span class="s2">|.&quot;</span>
<span class="p">)</span>


<span class="n">CEL_ESCAPES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">a&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\a</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">b&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\b</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">f&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\f</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">r&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">t&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">v&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\v</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">:</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&#39;&quot;</span><span class="p">:</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="celstr">
<a class="viewcode-back" href="../../api.html#celpy.__init__.celstr">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">celstr</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a CEL string literal, expanding escapes to create a Python string.</span>

<span class="sd">    It may be that built-in ``eval()`` might work for some of this, but</span>
<span class="sd">    the octal escapes aren&#39;t really viable.</span>

<span class="sd">    :param token: CEL token value</span>
<span class="sd">    :return: str</span>

<span class="sd">    ..  todo:: This can be refactored into celpy.celtypes.StringType.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">expand</span><span class="p">(</span><span class="n">match_iter</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Match</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">match_iter</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">expanded</span> <span class="o">=</span> <span class="n">match</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sa">r</span><span class="s2">&quot;\x&quot;</span><span class="p">:</span>
                <span class="n">expanded</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">16</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span><span class="sa">r</span><span class="s2">&quot;\u&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\U&quot;</span><span class="p">}:</span>
                <span class="n">expanded</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">16</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">expanded</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">8</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expanded</span> <span class="o">=</span> <span class="n">CEL_ESCAPES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">expanded</span>

    <span class="n">text</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="n">text</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">):</span>
        <span class="c1"># Raw; ignore ``\`` escapes</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&quot;&quot;&#39;</span> <span class="ow">or</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&#39;&#39;&#39;&quot;</span><span class="p">:</span>
            <span class="c1"># Long</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Short</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Cooked; expand ``\`` escapes</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&quot;&quot;&#39;</span> <span class="ow">or</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&#39;&#39;&#39;&quot;</span><span class="p">:</span>
            <span class="c1"># Long</span>
            <span class="n">match_iter</span> <span class="o">=</span> <span class="n">CEL_ESCAPES_PAT</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Short</span>
            <span class="n">match_iter</span> <span class="o">=</span> <span class="n">CEL_ESCAPES_PAT</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">expanded</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">match_iter</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">(</span><span class="n">expanded</span><span class="p">)</span></div>



<div class="viewcode-block" id="celbytes">
<a class="viewcode-back" href="../../api.html#celpy.__init__.celbytes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">celbytes</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BytesType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a CEL bytes literal, expanding escapes to create a Python bytes object.</span>

<span class="sd">    :param token: CEL token value</span>
<span class="sd">    :return: bytes</span>

<span class="sd">    ..  todo:: This can be refactored into celpy.celtypes.BytesType.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">expand</span><span class="p">(</span><span class="n">match_iter</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Match</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">match_iter</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">match</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sa">r</span><span class="s2">&quot;\x&quot;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">16</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sa">r</span><span class="s2">&quot;\u&quot;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">16</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">8</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">ord</span><span class="p">(</span><span class="n">CEL_ESCAPES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">match</span><span class="p">))</span>

    <span class="n">text</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="n">text</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;br&quot;</span><span class="p">:</span>
        <span class="c1"># Raw; ignore ``\`` escapes</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&quot;&quot;&#39;</span> <span class="ow">or</span> <span class="n">text</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&#39;&#39;&#39;&quot;</span><span class="p">:</span>
            <span class="c1"># Long</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BytesType</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">text</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Short</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BytesType</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">text</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">text</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
        <span class="c1"># Cooked; expand ``\`` escapes</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&quot;&quot;&#39;</span> <span class="ow">or</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&#39;&#39;&#39;&quot;</span><span class="p">:</span>
            <span class="c1"># Long</span>
            <span class="n">match_iter</span> <span class="o">=</span> <span class="n">CEL_ESCAPES_PAT</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Short</span>
            <span class="n">match_iter</span> <span class="o">=</span> <span class="n">CEL_ESCAPES_PAT</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">expanded</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BytesType</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">match_iter</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid bytes literal </span><span class="si">{</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expanded</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">CEL in Python</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Documentation Content:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">CLI Use of CEL-Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../integration.html">Application Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../structure.html">Architecture and Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../c7n_functions.html">C7N Functions Required</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2020, CapitalOne.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>
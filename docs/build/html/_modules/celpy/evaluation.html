<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>celpy.evaluation &#8212; CEL in Python  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for celpy.evaluation</h1><div class="highlight"><pre>
<span></span><span class="c1"># SPDX-Copyright: Copyright (c) Capital One Services, LLC</span>
<span class="c1"># SPDX-License-Identifier: Apache-2.0</span>
<span class="c1"># Copyright 2020 Capital One Services, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">CEL Interpreter using the AST directly.</span>

<span class="sd">The general idea is to map CEL operators to Python operators and push the</span>
<span class="sd">real work off to Python objects defined by the :py:mod:`celpy.celtypes` module.</span>

<span class="sd">CEL operator &quot;+&quot; is implemented by &quot;_+_&quot; function. We map this to :py:func:`operator.add`.</span>
<span class="sd">This will then look for `__add__()` methods in the various :py:class:`celpy.celtypes.CELType`</span>
<span class="sd">types.</span>

<span class="sd">In order to deal gracefully with missing and incomplete data,</span>
<span class="sd">exceptions are turned into first-class :py:class:`Result` objects.</span>
<span class="sd">They&#39;re not raised directly, but instead saved as part of the evaluation so that</span>
<span class="sd">short-circuit operators can ignore the exceptions.</span>

<span class="sd">This means that Python exceptions like :exc:`TypeError`, :exc:`IndexError`, and :exc:`KeyError`</span>
<span class="sd">are caught and transformed into :exc:`CELEvalError` objects.</span>

<span class="sd">The :py:class:`Resut` type hint is a union of the various values that are encountered</span>
<span class="sd">during evaluation. It&#39;s a union of the :py:class:`celpy.celtypes.CELTypes` type and the</span>
<span class="sd">:exc:`CELEvalError` exception.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">reduce</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Match</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Sized</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">lark</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lark.visitors</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">celpy.celtypes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">celpy.celparser</span><span class="w"> </span><span class="kn">import</span> <span class="n">tree_dump</span>

<span class="n">_USE_RE2</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">re2</span>

    <span class="n">_USE_RE2</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">function_matches</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Result&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">re2</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">re2</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="s2">&quot;match error&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>

<div class="viewcode-block" id="function_matches">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.function_matches">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">function_matches</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Result&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">re</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="s2">&quot;match error&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span></div>



<span class="c1"># A CEL type annotation. Used in an environment to describe objects as well as functions.</span>
<span class="c1"># This is a list of types, plus Callable for conversion functions.</span>
<span class="n">Annotation</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">CELType</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">[</span>
        <span class="o">...</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span>
    <span class="p">],</span>  <span class="c1"># Conversion functions and protobuf message type</span>
    <span class="n">Type</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">],</span>  <span class="c1"># Concrete class for annotations</span>
<span class="p">]</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;celpy.</span><span class="si">{</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="CELSyntaxError">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELSyntaxError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CELSyntaxError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CEL Syntax error -- the AST did not have the expected structure.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="CELSyntaxError.__init__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELSyntaxError.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line</span> <span class="o">=</span> <span class="n">line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span></div>
</div>



<div class="viewcode-block" id="CELUnsupportedError">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELUnsupportedError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CELUnsupportedError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feature unsupported by this implementation of CEL.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="CELUnsupportedError.__init__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELUnsupportedError.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line</span> <span class="o">=</span> <span class="n">line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span></div>
</div>



<div class="viewcode-block" id="CELEvalError">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CELEvalError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CEL evaluation problem. This can be saved as a temporary value for later use.</span>
<span class="sd">    This is politely ignored by logic operators to provide commutative short-circuit.</span>

<span class="sd">    We provide operator-like special methods so an instance of an error</span>
<span class="sd">    returns itself when operated on.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CELEvalError.__init__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">token</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">=</span> <span class="n">token</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">.</span><span class="n">line</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="o">.</span><span class="n">column</span></div>


<div class="viewcode-block" id="CELEvalError.__repr__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">:</span>
            <span class="c1"># This is rare</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">(*</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="si">}</span><span class="s2">, tree=</span><span class="si">{</span><span class="n">tree_dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">)</span><span class="si">!r}</span><span class="s2">, token=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="si">!r}</span><span class="s2">)&quot;</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">(*</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="si">}</span><span class="s2">, tree=</span><span class="si">{</span><span class="n">tree_dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">)</span><span class="si">!r}</span><span class="s2">)&quot;</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Some unit tests do not provide a mock tree.</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">(*</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="si">}</span><span class="s2">)&quot;</span>  <span class="c1"># pragma: no cover</span></div>


<div class="viewcode-block" id="CELEvalError.with_traceback">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.with_traceback">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_traceback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tb</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span></div>


<div class="viewcode-block" id="CELEvalError.__neg__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__neg__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__add__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__add__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__sub__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__sub__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__mul__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__mul__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__truediv__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__truediv__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__floordiv__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__floordiv__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__mod__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__mod__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__pow__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__pow__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__radd__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__radd__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__rsub__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__rsub__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__rmul__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__rmul__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__rtruediv__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__rtruediv__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__rfloordiv__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__rfloordiv__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__rmod__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__rmod__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__rpow__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__rpow__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CELEvalError.__eq__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__eq__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">args</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


<div class="viewcode-block" id="CELEvalError.__call__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.CELEvalError.__call__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CELEvalError&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<span class="c1"># The interim results extends celtypes to include itermediate CELEvalError exception objects.</span>
<span class="c1"># These can be deferred as part of commutative logical_and and logical_or operations.</span>
<span class="c1"># It includes the responses to type() queries, also.</span>
<span class="n">Result</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span>
    <span class="n">CELEvalError</span><span class="p">,</span>
    <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">CELType</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># The various functions that apply to CEL data.</span>
<span class="c1"># The evaluator&#39;s functions expand on the CELTypes to include CELEvalError and the</span>
<span class="c1"># celpy.celtypes.CELType union type, also.</span>
<span class="n">CELFunction</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Result</span><span class="p">]</span>

<span class="c1"># A combination of a CELType result or a function resulting from identifier evaluation.</span>
<span class="n">Result_Function</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Result</span><span class="p">,</span>
    <span class="n">CELFunction</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">Exception_Filter</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">]]]</span>

<span class="n">TargetFunc</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;TargetFunc&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">CELFunction</span><span class="p">)</span>


<div class="viewcode-block" id="eval_error">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.eval_error">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">eval_error</span><span class="p">(</span>
    <span class="n">new_text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">exc_class</span><span class="p">:</span> <span class="n">Exception_Filter</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TargetFunc</span><span class="p">],</span> <span class="n">TargetFunc</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrap a function to transform native Python exceptions to CEL CELEvalError values.</span>
<span class="sd">    Any exception of the given class is replaced with the new CELEvalError object.</span>

<span class="sd">    :param new_text: Text of the exception, e.g., &quot;divide by zero&quot;, &quot;no such overload&quot;)</span>
<span class="sd">        this is the return value if the :exc:`CELEvalError` becomes the result.</span>
<span class="sd">    :param exc_class: A Python exception class to match, e.g. ZeroDivisionError,</span>
<span class="sd">        or a sequence of exception classes (e.g. (ZeroDivisionError, ValueError))</span>
<span class="sd">    :return: A decorator that can be applied to a function</span>
<span class="sd">        to map Python exceptions to :exc:`CELEvalError` instances.</span>

<span class="sd">    This is used in the ``all()`` and ``exists()`` macros to silently ignore TypeError exceptions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">concrete_decorator</span><span class="p">(</span><span class="n">function</span><span class="p">:</span> <span class="n">TargetFunc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TargetFunc</span><span class="p">:</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">new_function</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">exc_class</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>  <span class="c1"># type: ignore[misc]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(*</span><span class="si">%s</span><span class="s2">, **</span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">ex</span>
                <span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">new_text</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(*</span><span class="si">%s</span><span class="s2">, **</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="k">raise</span>

        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">TargetFunc</span><span class="p">,</span> <span class="n">new_function</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">concrete_decorator</span></div>



<div class="viewcode-block" id="boolean">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.boolean">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">boolean</span><span class="p">(</span>
    <span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wraps boolean operators to create CEL BoolType results.</span>

<span class="sd">    :param function: One of the operator.lt, operator.gt, etc. comparison functions</span>
<span class="sd">    :return: Decorated function with type coercion.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bool_function</span><span class="p">(</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">bool_function</span></div>



<div class="viewcode-block" id="operator_in">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.operator_in">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">operator_in</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CEL contains test; ignores type errors.</span>

<span class="sd">    During evaluation of ``&#39;elem&#39; in [1, &#39;elem&#39;, 2]``,</span>
<span class="sd">    CEL will raise internal exceptions for ``&#39;elem&#39; == 1`` and ``&#39;elem&#39; == 2``.</span>
<span class="sd">    The :exc:`TypeError` exceptions are gracefully ignored.</span>

<span class="sd">    During evaluation of ``&#39;elem&#39; in [1u, &#39;str&#39;, 2, b&#39;bytes&#39;]``, however,</span>
<span class="sd">    CEL will raise internal exceptions every step of the way, and an exception</span>
<span class="sd">    value is the final result. (Not ``False`` from the one non-exceptional comparison.)</span>

<span class="sd">    It would be nice to make use of the following::</span>

<span class="sd">        eq_test = eval_error(&quot;no such overload&quot;, TypeError)(lambda x, y: x == y)</span>

<span class="sd">    It seems like ``next(iter(filter(lambda x: eq_test(c, x) for c in container))))``</span>
<span class="sd">    would do it. But. It&#39;s not quite right for the job.</span>

<span class="sd">    There need to be three results, something :py:func:`filter` doesn&#39;t handle.</span>
<span class="sd">    These are the chocies:</span>

<span class="sd">    -   True. There was a item found. Exceptions may or may not have been found.</span>
<span class="sd">    -   False. No item found AND no expceptions.</span>
<span class="sd">    -   CELEvalError. No item found AND at least one exception.</span>

<span class="sd">    To an extent this is a little like the ``exists()`` macro.</span>
<span class="sd">    We can think of ``container.contains(item)`` as ``container.exists(r, r == item)``.</span>
<span class="sd">    However, exists() tends to silence exceptions, where this can expost them.</span>

<span class="sd">    ..  todo:: This may be better done as</span>

<span class="sd">        ``reduce(logical_or, (item == c for c in container), BoolType(False))``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span><span class="p">:</span> <span class="n">Result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cast</span><span class="p">(</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">container</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;operator_in(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="s2">&quot;no such overload&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;operator_in(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">) = </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="function_size">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.function_size">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">function_size</span><span class="p">(</span><span class="n">container</span><span class="p">:</span> <span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The size() function applied to a Value. Delegate to Python&#39;s :py:func:`len`.</span>

<span class="sd">    (string) -&gt; int	string length</span>
<span class="sd">    (bytes) -&gt; int	bytes length</span>
<span class="sd">    (list(A)) -&gt; int	list size</span>
<span class="sd">    (map(A, B)) -&gt; int	map size</span>

<span class="sd">    For other types, this will raise a Python :exc:`TypeError`.</span>
<span class="sd">    (This is captured and becomes an :exc:`CELEvalError` Result.)</span>

<span class="sd">    ..  todo:: check container type for celpy.celtypes.StringType, celpy.celtypes.BytesType,</span>
<span class="sd">        celpy.celtypes.ListType and celpy.celtypes.MapType</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">container</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sized_container</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sized_container</span><span class="p">))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;function_size(</span><span class="si">%r</span><span class="s2">) = </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>



<span class="c1"># User-defined functions can override items in this mapping.</span>
<span class="n">base_functions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;!_&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_not</span><span class="p">,</span>
    <span class="s2">&quot;-_&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">,</span>
    <span class="s2">&quot;_+_&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
    <span class="s2">&quot;_-_&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span>
    <span class="s2">&quot;_*_&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span>
    <span class="s2">&quot;_/_&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span>
    <span class="s2">&quot;_%_&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span>
    <span class="s2">&quot;_&lt;_&quot;</span><span class="p">:</span> <span class="n">boolean</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">),</span>
    <span class="s2">&quot;_&lt;=_&quot;</span><span class="p">:</span> <span class="n">boolean</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">),</span>
    <span class="s2">&quot;_&gt;=_&quot;</span><span class="p">:</span> <span class="n">boolean</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">),</span>
    <span class="s2">&quot;_&gt;_&quot;</span><span class="p">:</span> <span class="n">boolean</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">),</span>
    <span class="s2">&quot;_==_&quot;</span><span class="p">:</span> <span class="n">boolean</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">),</span>
    <span class="s2">&quot;_!=_&quot;</span><span class="p">:</span> <span class="n">boolean</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">),</span>
    <span class="s2">&quot;_in_&quot;</span><span class="p">:</span> <span class="n">operator_in</span><span class="p">,</span>
    <span class="s2">&quot;_||_&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_or</span><span class="p">,</span>
    <span class="s2">&quot;_&amp;&amp;_&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_and</span><span class="p">,</span>
    <span class="s2">&quot;_?_:_&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_condition</span><span class="p">,</span>
    <span class="s2">&quot;_[_]&quot;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">,</span>
    <span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="n">function_size</span><span class="p">,</span>
    <span class="c1"># StringType methods</span>
    <span class="s2">&quot;endsWith&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">text</span><span class="p">)),</span>
    <span class="s2">&quot;startsWith&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">text</span><span class="p">)),</span>
    <span class="s2">&quot;matches&quot;</span><span class="p">:</span> <span class="n">function_matches</span><span class="p">,</span>
    <span class="s2">&quot;contains&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">text</span> <span class="ow">in</span> <span class="n">s</span><span class="p">),</span>
    <span class="c1"># TimestampType methods. Type details are redundant, but required because of the lambdas</span>
    <span class="s2">&quot;getDate&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tz_name</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getDate</span><span class="p">(</span><span class="n">tz_name</span><span class="p">)),</span>
    <span class="s2">&quot;getDayOfMonth&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tz_name</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">getDayOfMonth</span><span class="p">(</span><span class="n">tz_name</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="s2">&quot;getDayOfWeek&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tz_name</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">getDayOfWeek</span><span class="p">(</span><span class="n">tz_name</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="s2">&quot;getDayOfYear&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tz_name</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">getDayOfYear</span><span class="p">(</span><span class="n">tz_name</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="s2">&quot;getFullYear&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tz_name</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">getFullYear</span><span class="p">(</span><span class="n">tz_name</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="s2">&quot;getMonth&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tz_name</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getMonth</span><span class="p">(</span><span class="n">tz_name</span><span class="p">)),</span>
    <span class="c1"># TimestampType and DurationType methods</span>
    <span class="s2">&quot;getHours&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tz_name</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">getHours</span><span class="p">(</span><span class="n">tz_name</span><span class="p">)),</span>
    <span class="s2">&quot;getMilliseconds&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tz_name</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">getMilliseconds</span><span class="p">(</span><span class="n">tz_name</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="s2">&quot;getMinutes&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tz_name</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">getMinutes</span><span class="p">(</span><span class="n">tz_name</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="s2">&quot;getSeconds&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tz_name</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">getSeconds</span><span class="p">(</span><span class="n">tz_name</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="c1"># type conversion functions</span>
    <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">,</span>
    <span class="s2">&quot;bytes&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BytesType</span><span class="p">,</span>
    <span class="s2">&quot;double&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">DoubleType</span><span class="p">,</span>
    <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">DurationType</span><span class="p">,</span>
    <span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">,</span>
    <span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">,</span>  <span class="c1"># https://github.com/google/cel-spec/issues/123</span>
    <span class="s2">&quot;map&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">,</span>
    <span class="s2">&quot;null_type&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span>
    <span class="s2">&quot;string&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">,</span>
    <span class="s2">&quot;timestamp&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">TimestampType</span><span class="p">,</span>
    <span class="s2">&quot;uint&quot;</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">UintType</span><span class="p">,</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="Referent">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Referent">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Referent</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Name can refer to any of the following things:</span>

<span class="sd">    -   Annotations -- initially most names are these</span>
<span class="sd">        or a CELFunction that may implement a type.</span>
<span class="sd">        Must be provided as part of the initialization.</span>

<span class="sd">    -   NameContainer -- some names are these. This is true</span>
<span class="sd">        when the name is *not* provided as part of the initialization because</span>
<span class="sd">        we discovered the name during type or environment binding.</span>

<span class="sd">    -   celpy.celtypes.Value -- many annotations also have values.</span>
<span class="sd">        These are provided **after** Annotations, and require them.</span>

<span class="sd">    -   CELEvalError -- This seems unlikely, but we include it because it&#39;s possible.</span>

<span class="sd">    -   Functions -- All of the type conversion functions are names in a NameContainer.</span>

<span class="sd">    A name can be ambiguous and refer to both a nested ``NameContainer`` as well</span>
<span class="sd">    as a ``celpy.celtypes.Value`` (usually a MapType instance.)</span>

<span class="sd">    Object ``b`` has two possible meanings:</span>

<span class="sd">    -   ``b.c`` is a NameContainer for ``c``, a string.</span>

<span class="sd">    -   ``b`` is a mapping, and ``b.c`` is syntax sugar for ``b[&#39;c&#39;]``.</span>

<span class="sd">    The &quot;longest name&quot; rule means that the useful value is the &quot;c&quot; object</span>
<span class="sd">    in the nested ``NameContainer``.</span>
<span class="sd">    The syntax sugar interpretation is done in the rare case we can&#39;t find the ``NameContainer``.</span>

<span class="sd">    &gt;&gt;&gt; nc = NameContainer(&quot;c&quot;, celpy.celtypes.StringType)</span>
<span class="sd">    &gt;&gt;&gt; b = Referent(celpy.celtypes.MapType)</span>
<span class="sd">    &gt;&gt;&gt; b.value = celpy.celtypes.MapType({&quot;c&quot;: &quot;oops&quot;})</span>
<span class="sd">    &gt;&gt;&gt; b.value == celpy.celtypes.MapType({&quot;c&quot;: &quot;oops&quot;})</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; b.container = nc</span>
<span class="sd">    &gt;&gt;&gt; b.value == nc</span>
<span class="sd">    True</span>

<span class="sd">    In effect, this class is</span>
<span class="sd">    ::</span>

<span class="sd">        Referent = Union[</span>
<span class="sd">            Annotation,</span>
<span class="sd">            celpy.celtypes.Value,</span>
<span class="sd">            CELEvalError,</span>
<span class="sd">            CELFunction,</span>
<span class="sd">        ]</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Referent.__init__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Referent.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ref_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Annotation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1"># Union[</span>
        <span class="c1"># None, Annotation, celpy.celtypes.Value, CELEvalError,</span>
        <span class="c1"># CELFunction, &#39;NameContainer&#39;</span>
        <span class="c1"># ] = None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Annotation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">container</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;NameContainer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">Annotation</span><span class="p">,</span>
            <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span>
            <span class="n">CELEvalError</span><span class="p">,</span>
            <span class="n">CELFunction</span><span class="p">,</span>
            <span class="s2">&quot;NameContainer&quot;</span><span class="p">,</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_set</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ref_to</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">annotation</span> <span class="o">=</span> <span class="n">ref_to</span></div>


<div class="viewcode-block" id="Referent.__repr__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Referent.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(annotation=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">annotation</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;container=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">container</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;_value=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="si">!r}</span><span class="s2">)&quot;</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Annotation</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">,</span> <span class="s2">&quot;NameContainer&quot;</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The longest-path rule means we prefer ``NameContainer`` over any locally defined value.</span>
<span class="sd">        Otherwise, we&#39;ll provide a value if there is one.</span>
<span class="sd">        Finally, we&#39;ll provide the annotation if there&#39;s no value.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">container</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">container</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_set</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Not part of a namespace path. Nor was a value set.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotation</span>

    <span class="nd">@value</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ref_to</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">Annotation</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">,</span> <span class="s2">&quot;NameContainer&quot;</span>
        <span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">ref_to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value_set</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Referent.clone">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Referent.clone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Referent&quot;</span><span class="p">:</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">Referent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">container</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">container</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_value_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_set</span>
        <span class="k">return</span> <span class="n">new</span></div>
</div>



<span class="c1"># A name resolution context is a mapping from an identifer to a Value or a ``NameContainer``.</span>
<span class="c1"># This reflects some murkiness in the name resolution algorithm that needs to be cleaned up.</span>
<span class="n">Context</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="s2">&quot;NameContainer&quot;</span><span class="p">]]</span>


<span class="c1"># Copied from cel.lark</span>
<span class="n">IDENT</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[_a-zA-Z][_a-zA-Z0-9]*&quot;</span>


<div class="viewcode-block" id="NameContainer">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.NameContainer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NameContainer</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Referent</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A namespace that fulfills the CEL name resolution requirement.</span>

<span class="sd">    ::</span>

<span class="sd">        Scenario: &quot;qualified_identifier_resolution_unchecked&quot;</span>
<span class="sd">          &quot;namespace resolution should try to find the longest prefix for the evaluator.&quot;</span>

<span class="sd">    NameContainer instances can be chained (via parent) to create a sequence of searchable</span>
<span class="sd">    locations for a name.</span>

<span class="sd">    -   Local-most is an Activation with local variables within a macro.</span>
<span class="sd">        These are part of a nested chain of Activations for each macro. Each local activation</span>
<span class="sd">        is a child with a reference to the parent Activation.</span>

<span class="sd">    -   Parent of any local Activation is the overall Activation for this CEL evaluation.</span>
<span class="sd">        The overall Activation contains a number of NameContainers:</span>

<span class="sd">        -   The global variable bindings.</span>

<span class="sd">        -   Bindings of function definitions. This is the default set of functions for CEL</span>
<span class="sd">            plus any add-on functions introduced by C7N.</span>

<span class="sd">        -   The run-time annotations from the environment. There are two kinds:</span>

<span class="sd">            -   Protobuf message definitions. These are types, really.</span>

<span class="sd">            -   Annotations for global variables. The annotations tend to be hidden by the values.</span>
<span class="sd">                They&#39;re in the lookup chain to simplify access to protobuf messages.</span>

<span class="sd">        -   The environment also provides the built-in type names and aliases for the</span>
<span class="sd">            :mod:`celtypes` package of built-in types.</span>

<span class="sd">    This means name resolution marches from local-most to remote-most, searching for a binding.</span>
<span class="sd">    The global variable bindings have a local-most value and a more remote annotation.</span>
<span class="sd">    The annotations (i.e. protobuf message types) have only a fairly remote annotation without</span>
<span class="sd">    a value.</span>

<span class="sd">    Structure.</span>

<span class="sd">    A NameContainer is a mapping from names to Referents.</span>

<span class="sd">    A Referent can be one of three things.</span>

<span class="sd">    -   A NameContainer further down the path</span>
<span class="sd">    -   An Annotation</span>
<span class="sd">    -   An Annotation with a value.</span>

<span class="sd">    Loading Names.</span>

<span class="sd">    There are several &quot;phases&quot; to building the chain of ``NameContainer`` instances.</span>

<span class="sd">    1.  The ``Activation`` creates the initial ``name : annotation`` bindings.</span>
<span class="sd">        Generally, the names are type names, like &quot;int&quot;, bound to :py:class:`celtypes.IntType`.</span>
<span class="sd">        In some cases, the name is a future variable name, &quot;resource&quot;,</span>
<span class="sd">        bound to :py:class:`celtypes.MapType`.</span>

<span class="sd">    2.  The ``Activation`` creates a second ``NameContainer`` that has variable names.</span>
<span class="sd">        This has a reference back to the parent to resolve names that are types.</span>

<span class="sd">    This involves decomposing the paths of names to make a tree of nested ``NameContainers``.</span>
<span class="sd">    Upper-level containers don&#39;t (necessarily) have types or values -- they&#39;re merely</span>
<span class="sd">    ``NameContainer`` along the path to the target names.</span>

<span class="sd">    Resolving Names.</span>

<span class="sd">    See https://github.com/google/cel-spec/blob/master/doc/langdef.md#name-resolution</span>

<span class="sd">    There are three cases required in the :py:class:`Evaluator` engine.</span>

<span class="sd">    -   Variables and Functions. These are ``Result_Function`` instances: i.e., ordinary values.</span>

<span class="sd">    -   ``Name.Name`` can be navigation into a protobuf package, when ``Name`` is protobuf package.</span>
<span class="sd">        The idea is to locate the longest possible match.</span>

<span class="sd">        If a.b is a name to be resolved in the context of a protobuf declaration with scope A.B,</span>
<span class="sd">        then resolution is attempted, in order, as A.B.a.b, A.a.b, and finally a.b.</span>
<span class="sd">        To override this behavior, one can use .a.b;</span>
<span class="sd">        this name will only be attempted to be resolved in the root scope, i.e. as a.b.</span>

<span class="sd">    -   ``Name.Name`` can be syntactic sugar for indexing into a mapping when ``Name`` is a value of</span>
<span class="sd">        ``MapType`` or a ``MessageType``. It&#39;s evaluated as if it was ``Name[&quot;Name&quot;]``.</span>
<span class="sd">        This is a fall-back plan if the previous resolution failed.</span>

<span class="sd">    The longest chain of nested packages *should* be resolved first.</span>
<span class="sd">    This will happen when each name is a ``NameContainer`` object containing</span>
<span class="sd">    other ``NameContainer`` objects.</span>

<span class="sd">    The chain of evaluations for ``IDENT . IDENT . IDENT`` is (in effect)</span>
<span class="sd">    ::</span>

<span class="sd">        member_dot(member_dot(primary(IDENT), IDENT), IDENT)</span>

<span class="sd">    This makes the ``member_dot`` processing left associative.</span>

<span class="sd">    The ``primary(IDENT)`` resolves to a CEL object of some kind.</span>
<span class="sd">    Once the ``primary(IDENT)`` has been resolved, it establishes a context</span>
<span class="sd">    for subsequent ``member_dot`` methods.</span>

<span class="sd">    -   If this is a ``MapType`` or a ``MessageType`` with an object,</span>
<span class="sd">        then ``member_dot`` will pluck out a field value and return this.</span>

<span class="sd">    -   If this is a ``NameContainer`` or a ``PackageType`` then the ``member_dot``</span>
<span class="sd">        will pluck out a sub-package or ``EnumType`` or ``MessageType``</span>
<span class="sd">        and return the type object instead of a value.</span>
<span class="sd">        At some point a ``member_object`` production will build an object from the type.</span>

<span class="sd">    The evaluator&#39;s :meth:`ident_value` method resolves the identifier into the ``Referent``.</span>

<span class="sd">    Acceptance Test Case</span>

<span class="sd">    We have two names</span>

<span class="sd">    -   `a.b` -&gt; NameContainer in which c = &quot;yeah&quot;. (i.e., a.b.c : &quot;yeah&quot;)</span>
<span class="sd">    -   `a.b` -&gt; Mapping with {&quot;c&quot;: &quot;oops&quot;}.</span>

<span class="sd">    This means any given name can have as many as three meanings:</span>

<span class="sd">    -   Primarily as a NameContainer. This resolves name.name.name to find the longest</span>
<span class="sd">        namespace possible.</span>

<span class="sd">    -   Secondarily as a Mapping. This will be a fallback when name.name.name is really</span>
<span class="sd">        syntactic sugar for name.name[&#39;name&#39;].</span>

<span class="sd">    -   Finally as a type annotation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ident_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">IDENT</span><span class="p">)</span>
    <span class="n">extended_name_path</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;^</span><span class="se">\\</span><span class="s2">.?</span><span class="si">{</span><span class="n">IDENT</span><span class="si">}</span><span class="s2">(?:</span><span class="se">\\</span><span class="s2">.</span><span class="si">{</span><span class="n">IDENT</span><span class="si">}</span><span class="s2">)*$&quot;</span><span class="p">)</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;celpy.NameContainer&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="NameContainer.__init__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.NameContainer.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ref_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Referent</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;NameContainer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">ref_to</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">ref_to</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NameContainer</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span></div>


<div class="viewcode-block" id="NameContainer.load_annotations">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.NameContainer.load_annotations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_annotations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used by an ``Activation`` to build a container used to resolve</span>
<span class="sd">        long path names into nested NameContainers.</span>
<span class="sd">        Sets annotations for all supplied identifiers.</span>

<span class="sd">        ``{&quot;name1.name2&quot;: annotation}`` becomes two things:</span>

<span class="sd">        1. nc2 = NameContainer({&quot;name2&quot; : Referent(annotation)})</span>

<span class="sd">        2. nc1 = NameContainer({&quot;name1&quot; : Referent(nc2)})</span>

<span class="sd">        :param names: A dictionary of {&quot;name1.name1....&quot;: Referent, ...} items.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">refers_to</span> <span class="ow">in</span> <span class="n">names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;load_annotations </span><span class="si">%r</span><span class="s2"> : </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">refers_to</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_name_path</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span>

            <span class="c1"># Expand &quot;name1.name2....&quot;: refers_to into [&quot;name1&quot;, &quot;name2&quot;, ...]: refers_to</span>
            <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ident_pat</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Referent</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">container</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ref</span><span class="o">.</span><span class="n">container</span> <span class="o">=</span> <span class="n">NameContainer</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
                <span class="n">context</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">container</span>
            <span class="n">context</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="n">Referent</span><span class="p">(</span><span class="n">refers_to</span><span class="p">))</span></div>


<div class="viewcode-block" id="NameContainer.load_values">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.NameContainer.load_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update annotations with actual values.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">refers_to</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;load_values </span><span class="si">%r</span><span class="s2"> : </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">refers_to</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_name_path</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span>

            <span class="c1"># Expand &quot;name1.name2....&quot;: refers_to into [&quot;name1&quot;, &quot;name2&quot;, ...]: refers_to</span>
            <span class="c1"># Update NameContainer(&quot;name1&quot;, NameContainer(&quot;name2&quot;, NameContainer(..., refers_to)))</span>
            <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ident_pat</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Referent</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">container</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ref</span><span class="o">.</span><span class="n">container</span> <span class="o">=</span> <span class="n">NameContainer</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
                <span class="n">context</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">container</span>
            <span class="n">context</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">final</span><span class="p">,</span> <span class="n">Referent</span><span class="p">())</span>  <span class="c1"># No annotation.</span>
            <span class="n">context</span><span class="p">[</span><span class="n">final</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">refers_to</span></div>


<div class="viewcode-block" id="NameContainer.NotFound">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.NameContainer.NotFound">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">NotFound</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raised locally when a name is not found in the middle of package search.</span>
<span class="sd">        We can&#39;t return ``None`` from find_name because that&#39;s a valid value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">pass</span></div>


<div class="viewcode-block" id="NameContainer.dict_find_name">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.NameContainer.dict_find_name">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dict_find_name</span><span class="p">(</span><span class="n">some_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Referent</span><span class="p">],</span> <span class="n">path</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extension to navgiate into mappings, messages, and packages.</span>

<span class="sd">        :param some_dict: An instance of a MapType, MessageType, or PackageType.</span>
<span class="sd">        :param path: names to follow into the structure.</span>
<span class="sd">        :returns: Value found down inside the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">NameContainer</span><span class="o">.</span><span class="n">dict_find_name</span><span class="p">(</span>
                    <span class="n">cast</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Referent</span><span class="p">],</span> <span class="n">some_dict</span><span class="p">[</span><span class="n">head</span><span class="p">]),</span> <span class="n">tail</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">NameContainer</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> not found in </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">some_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">raise</span> <span class="n">NameContainer</span><span class="o">.</span><span class="n">NotFound</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">some_dict</span><span class="p">)</span></div>


<div class="viewcode-block" id="NameContainer.find_name">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.NameContainer.find_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;NameContainer&quot;</span><span class="p">,</span> <span class="n">Result</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the name by searching down through nested packages or raise NotFound.</span>
<span class="sd">        This is a kind of in-order tree walk of contained packages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sub_context</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">head</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> not found in </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">raise</span> <span class="n">NameContainer</span><span class="o">.</span><span class="n">NotFound</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_context</span><span class="p">,</span> <span class="n">NameContainer</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">sub_context</span><span class="o">.</span><span class="n">find_name</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">sub_context</span><span class="p">,</span>
                <span class="p">(</span>
                    <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MessageType</span><span class="p">,</span>
                    <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">,</span>
                    <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">PackageType</span><span class="p">,</span>
                    <span class="nb">dict</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">):</span>
                <span class="c1"># Out of defined NameContainers, moving into Values: Messages, Mappings or Packages</span>
                <span class="c1"># Make a fake Referent return value.</span>
                <span class="n">item</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;NameContainer&quot;</span><span class="p">,</span> <span class="n">Result</span><span class="p">]</span> <span class="o">=</span> <span class="n">NameContainer</span><span class="o">.</span><span class="n">dict_find_name</span><span class="p">(</span>
                    <span class="n">cast</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Referent</span><span class="p">],</span> <span class="n">sub_context</span><span class="p">),</span> <span class="n">tail</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">item</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Fully matched. No more Referents with NameContainers or Referents with Mappings.</span>
                <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">NameContainer</span><span class="p">,</span> <span class="n">sub_context</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fully matched. This NameContainer is what we were looking for.</span>
            <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="NameContainer.parent_iter">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.NameContainer.parent_iter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parent_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s2">&quot;NameContainer&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Yield this NameContainer and all of its parents to create a flat list.&quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent_iter</span><span class="p">()</span></div>


<div class="viewcode-block" id="NameContainer.resolve_name">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.NameContainer.resolve_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resolve_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">package</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Referent</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search with less and less package prefix until we find the thing.</span>

<span class="sd">        Resolution works as follows.</span>
<span class="sd">        If a.b is a name to be resolved in the context of a protobuf declaration with scope A.B,</span>
<span class="sd">        then resolution is attempted, in order, as</span>

<span class="sd">        1. A.B.a.b.  (Search for &quot;a&quot; in paackage &quot;A.B&quot;; the &quot;.b&quot; is handled separately.)</span>

<span class="sd">        2. A.a.b.  (Search for &quot;a&quot; in paackage &quot;A&quot;; the &quot;.b&quot; is handled separately.)</span>

<span class="sd">        3. (finally) a.b.  (Search for &quot;a&quot; in paackage None; the &quot;.b&quot; is handled separately.)</span>

<span class="sd">        To override this behavior, one can use .a.b;</span>
<span class="sd">        this name will only be attempted to be resolved in the root scope, i.e. as a.b.</span>

<span class="sd">        We Start with the longest package name, a ``List[str]`` assigned to ``target``.</span>

<span class="sd">        Given a target, search through this ``NameContainer`` and all parents in the</span>
<span class="sd">        :meth:`parent_iter` iterable.</span>
<span class="sd">        The first name we find in the parent sequence is the goal.</span>
<span class="sd">        This is because values are first, type annotations are laast.</span>

<span class="sd">        If we can&#39;t find the identifier with given package target,</span>
<span class="sd">        truncate the package name from the end to create a new target and try again.</span>
<span class="sd">        This is a bottom-up look that favors the longest name.</span>

<span class="sd">        :param package: Prefix string &quot;name.name.name&quot;</span>
<span class="sd">        :param name: The variable we&#39;re looking for</span>
<span class="sd">        :return: Name resolution as a Rereferent, often a value, but maybe a package or an</span>
<span class="sd">            annotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;resolve_name(</span><span class="si">%r</span><span class="s2">.</span><span class="si">%r</span><span class="s2">) in </span><span class="si">%s</span><span class="s2">, parent=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">package</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Longest Name</span>
        <span class="k">if</span> <span class="n">package</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ident_pat</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">package</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
        <span class="c1"># Pool of matches</span>
        <span class="n">matches</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;NameContainer&quot;</span><span class="p">,</span> <span class="n">Result</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Target has an extra item to make the len non-zero.</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">matches</span> <span class="ow">and</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_iter</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">package_ident</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span> <span class="o">+</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="n">match</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;NameContainer&quot;</span><span class="p">,</span> <span class="n">Result</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">find_name</span><span class="p">(</span><span class="n">package_ident</span><span class="p">)</span>
                    <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">package_ident</span><span class="p">,</span> <span class="n">match</span><span class="p">))</span>
                <span class="k">except</span> <span class="n">NameContainer</span><span class="o">.</span><span class="n">NotFound</span><span class="p">:</span>
                    <span class="c1"># No matches; move to the parent and try again.</span>
                    <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;resolve_name: target=</span><span class="si">%s</span><span class="s2">+[</span><span class="si">%r</span><span class="s2">], matches=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">matches</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">matches</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># This feels hackish -- it should be the first referent value.</span>
        <span class="c1"># Find the longest name match.p</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">path_value</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Referent</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="NameContainer.clone">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.NameContainer.clone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;NameContainer&quot;</span><span class="p">:</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">NameContainer</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new</span></div>


<div class="viewcode-block" id="NameContainer.__repr__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.NameContainer.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">, parent=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="si">}</span><span class="s2">)&quot;</span></div>
</div>



<div class="viewcode-block" id="Activation">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Activation">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Activation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Namespace with variable bindings and type name (&quot;annotation&quot;) bindings.</span>

<span class="sd">    ..  rubric:: Life and Content</span>

<span class="sd">    An Activation is created by an Environment and contains the annotations</span>
<span class="sd">    (and a package name) from that Environment. Variables are loaded into the</span>
<span class="sd">    activation for evaluation.</span>

<span class="sd">    A nested Activation is created each time we evaluate a macro.</span>

<span class="sd">    An Activation contains a ``NameContainer`` instance to resolve identifers.</span>
<span class="sd">    (This may be a needless distinction and the two classes could, perhaps, be combined.)</span>

<span class="sd">    ..  todo:: The environment&#39;s annotations are type names used for protobuf.</span>

<span class="sd">    ..  rubric:: Chaining/Nesting</span>

<span class="sd">    Activations can form a chain so locals are checked first.</span>
<span class="sd">    Activations can nest via macro evaluation, creating transient local variables.</span>

<span class="sd">    ::</span>

<span class="sd">        ``&quot;[2, 4, 6].map(n, n / 2)&quot;``</span>

<span class="sd">    means nested activations with ``n`` bound to 2, 4, and 6 respectively.</span>
<span class="sd">    The resulting objects then form a resulting list.</span>

<span class="sd">    This is used by an :py:class:`Evaluator` as follows::</span>

<span class="sd">        sub_activation: Activation = self.activation.nested_activation()</span>
<span class="sd">        sub_eval: Evaluator = self.sub_eval(sub_activation)</span>
<span class="sd">        sub_eval_partial: Callable[[Value], Value] = sub_eval.partial(</span>
<span class="sd">            tree_for_variable, tree_for_expression)</span>
<span class="sd">        push(celtypes.ListType(map(sub_eval_partial, pop()))</span>

<span class="sd">    The ``localized_eval()`` creates a new :py:class:`Activation`</span>
<span class="sd">    and an associated :py:class:`Evaluator` for this nested activation context.</span>
<span class="sd">    It uses the :py:class:`Evaluator.visit` method to evaluate the given expression for</span>
<span class="sd">    a new object bound to the given variable.</span>

<span class="sd">    ..  rubric:: Namespace Creation</span>

<span class="sd">    We expand ``{&quot;a.b.c&quot;: 42}`` to create nested namespaces: ``{&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: 42}}}``.</span>

<span class="sd">    This depends on two syntax rules to define the valid names::</span>

<span class="sd">        member        : primary</span>
<span class="sd">                      | member &quot;.&quot; IDENT [&quot;(&quot; [exprlist] &quot;)&quot;]</span>

<span class="sd">        primary       : [&quot;.&quot;] IDENT [&quot;(&quot; [exprlist] &quot;)&quot;]</span>

<span class="sd">    Ignore the ``[&quot;(&quot; [exprlist] &quot;)&quot;]`` options used for member functions.</span>
<span class="sd">    We have members and primaries, both of which depend on the following lexical rule::</span>

<span class="sd">        IDENT         : /[_a-zA-Z][_a-zA-Z0-9]*/</span>

<span class="sd">    Name expansion is handled in order of length. Here&#39;s why::</span>

<span class="sd">        Scenario: &quot;qualified_identifier_resolution_unchecked&quot;</span>
<span class="sd">              &quot;namespace resolution should try to find the longest prefix for the evaluator.&quot;</span>

<span class="sd">    Most names start with ``IDENT``, but a primary can start with ``.``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Activation.__init__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Activation.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">annotations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">package</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">vars</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Context</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Activation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an Activation.</span>

<span class="sd">        The annotations are loaded first. The variables are loaded second, and placed</span>
<span class="sd">        in front of the annotations in the chain of name resolutions. Values come before</span>
<span class="sd">        annotations.</span>

<span class="sd">        :param annotations: Variables and type annotations.</span>
<span class="sd">            Annotations are loaded first to serve as defaults to create a parent NameContainer.</span>
<span class="sd">        :param package: The package name to assume as a prefix for name resolution.</span>
<span class="sd">        :param vars: Variables and their values, loaded to update the NameContainer.</span>
<span class="sd">        :param parent: A parent activation in the case of macro evaluations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Activation(annotations=</span><span class="si">%r</span><span class="s2">, package=</span><span class="si">%r</span><span class="s2">, vars=</span><span class="si">%r</span><span class="s2">, parent=</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
            <span class="n">annotations</span><span class="p">,</span>
            <span class="n">package</span><span class="p">,</span>
            <span class="nb">vars</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Seed the annotation identifiers for this activation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="p">:</span> <span class="n">NameContainer</span> <span class="o">=</span> <span class="n">NameContainer</span><span class="p">(</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">identifiers</span> <span class="k">if</span> <span class="n">parent</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">annotations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">load_annotations</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span>

        <span class="c1"># The name of the run-time package -- an assumed prefix for name resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">package</span> <span class="o">=</span> <span class="n">package</span>

        <span class="c1"># Create a child NameContainer with variables (if any.)</span>
        <span class="k">if</span> <span class="nb">vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="n">Activation</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># Deprecated legacy feature.</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Use Activation.clone()&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Set values from a dictionary of names and values.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">load_values</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span></div>


<div class="viewcode-block" id="Activation.clone">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Activation.clone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Activation&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a clone of this activation with a deep copy of the identifiers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="n">Activation</span><span class="p">()</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">package</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">package</span>
        <span class="n">clone</span><span class="o">.</span><span class="n">identifiers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">clone</span></div>


<div class="viewcode-block" id="Activation.nested_activation">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Activation.nested_activation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nested_activation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">annotations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Annotation</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">vars</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Context</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Activation&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a nested sub-Activation that chains to the current activation.</span>
<span class="sd">        The sub-activations don&#39;t have the same implied package context,</span>

<span class="sd">        :param annotations: Variable type annotations</span>
<span class="sd">        :param vars: Variables with literals to be converted to the desired types.</span>
<span class="sd">        :return: An ``Activation`` that chains to this Activation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">Activation</span><span class="p">(</span>
            <span class="n">annotations</span><span class="o">=</span><span class="n">annotations</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="nb">vars</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">package</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span></div>


<div class="viewcode-block" id="Activation.resolve_variable">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Activation.resolve_variable">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resolve_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">NameContainer</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the object referred to by the name.</span>

<span class="sd">        An Activation usually has a chain of NameContainers to be searched.</span>

<span class="sd">        A variable can refer to an annotation and/or a value and/or a nested</span>
<span class="sd">        container.  Most of the time, we want the `value` attribute of the Referent.</span>
<span class="sd">        This can be a Result (a Union[Value, CelType])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">container_or_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">NameContainer</span><span class="p">],</span> <span class="n">container_or_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Activation.__repr__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Activation.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(annotations=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">parent</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;package=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">package</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;vars=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="si">!r}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;parent=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">parent</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FindIdent">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.FindIdent">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FindIdent</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">visitors</span><span class="o">.</span><span class="n">Visitor_Recursive</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Locate the ident token at the bottom of an AST.</span>

<span class="sd">    This is needed to find the bind variable for macros.</span>

<span class="sd">    It works by doing a &quot;visit&quot; on the entire tree, but saving</span>
<span class="sd">    the details of the ``ident`` nodes only.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FindIdent.__init__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.FindIdent.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ident_token</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="FindIdent.ident">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.FindIdent.ident">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ident</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ident_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ident_token</span> <span class="o">=</span> <span class="n">ident_token</span><span class="o">.</span><span class="n">value</span></div>


<div class="viewcode-block" id="FindIdent.in_tree">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.FindIdent.in_tree">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_tree</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;FindIdent&quot;</span><span class="p">],</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="n">FindIdent</span><span class="p">()</span>
        <span class="n">fi</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fi</span><span class="o">.</span><span class="n">ident_token</span></div>
</div>



<div class="viewcode-block" id="trace">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.trace">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">trace</span><span class="p">(</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;Evaluator&quot;</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="s2">&quot;Evaluator&quot;</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to create consistent evaluation trace logging.</span>
<span class="sd">    This only works for a class with a ``level`` attribute.</span>
<span class="sd">    This is generally applied to the methods matching rule names.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">concrete_method</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;Evaluator&quot;</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">*</span> <span class="s2">&quot;| &quot;</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2"> -&gt; </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">*</span> <span class="s2">&quot;| &quot;</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">concrete_method</span></div>



<div class="viewcode-block" id="Evaluator">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Evaluator</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">visitors</span><span class="o">.</span><span class="n">Interpreter</span><span class="p">[</span><span class="n">Result</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate an AST in the context of a specific Activation.</span>

<span class="sd">    See https://github.com/google/cel-go/blob/master/examples/README.md</span>

<span class="sd">    General Evaluation.</span>

<span class="sd">    An AST node must call ``self.visit_children(tree)`` explicitly</span>
<span class="sd">    to build the values for all the children of this node.</span>

<span class="sd">    Exceptions.</span>

<span class="sd">    To handle ``2 / 0 || true``, the ``||``, ``&amp;&amp;``, and ``?:`` operators</span>
<span class="sd">    do not trivially evaluate and raise exceptions. They bottle up the</span>
<span class="sd">    exceptions and treat them as a kind of undecided value.</span>

<span class="sd">    Identifiers.</span>

<span class="sd">    Identifiers have three meanings:</span>

<span class="sd">    -   An object. This is either a variable provided in the activation or a function provided</span>
<span class="sd">        when building an execution. Objects also have type annotations.</span>

<span class="sd">    -   A type annotation without an object, This is used to build protobuf messages.</span>

<span class="sd">    -   A macro name. The ``member_dot_arg`` construct may have a macro.</span>
<span class="sd">        Plus the ``ident_arg`` construct may also have a ``dyn()`` or ``has()`` macro.</span>
<span class="sd">        See below for more.</span>

<span class="sd">    Other than macros, a name maps to an ``Referent`` instance. This will have an</span>
<span class="sd">    annotation and -- perhaps -- an associated object.</span>

<span class="sd">    Names have nested paths. ``a.b.c`` is a mapping, ``a``, that contains a mapping, ``b``,</span>
<span class="sd">    that contains ``c``.</span>

<span class="sd">    **MACROS ARE SPECIAL**.</span>

<span class="sd">    The macros do not **all** simply visit their children to perform evaluation.</span>
<span class="sd">    There are three cases:</span>

<span class="sd">    - ``dyn()`` does effectively nothing.</span>
<span class="sd">      It visits it&#39;s children, but also provides progressive type resolution</span>
<span class="sd">      through annotation of the AST.</span>

<span class="sd">    - ``has()`` attempts to visit the child and does a boolean transformation</span>
<span class="sd">      on the result.</span>
<span class="sd">      This is a macro because it doesn&#39;t raise an exception for a missing</span>
<span class="sd">      member item reference, but instead maps an exception to False.</span>
<span class="sd">      It doesn&#39;t return the value found, for a member item reference; instead, it maps</span>
<span class="sd">      this to True.</span>

<span class="sd">    - The various ``member.macro()`` constructs do **NOT** visit children.</span>
<span class="sd">      They create a nested evaluation environment for the child variable name and expression.</span>

<span class="sd">    The :py:meth:`member` method implements the macro evaluation behavior.</span>
<span class="sd">    It does not **always** trivially descend into the children.</span>
<span class="sd">    In the case of macros, the member evaluates one child tree in the presence</span>
<span class="sd">    of values from another child tree using specific variable binding in a kind</span>
<span class="sd">    of stack frame.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;celpy.Evaluator&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Evaluator.__init__">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ast</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span>
        <span class="n">activation</span><span class="p">:</span> <span class="n">Activation</span><span class="p">,</span>
        <span class="n">functions</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">CELFunction</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an evaluator for an AST with specific variables and functions.</span>

<span class="sd">        :param ast: The AST to evaluate.</span>
<span class="sd">        :param activation: The variable bindings to use.</span>
<span class="sd">        :param functions: The functions to use. If nothing is supplied, the default</span>
<span class="sd">            global `base_functions` are used. Otherwise a ChainMap is created so</span>
<span class="sd">            these local functions override the base functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ast</span> <span class="o">=</span> <span class="n">ast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_activation</span> <span class="o">=</span> <span class="n">activation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_activation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CELFunction</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">local_functions</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span> <span class="ow">or</span> <span class="p">[]}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">ChainMap</span><span class="p">(</span><span class="n">local_functions</span><span class="p">,</span> <span class="n">base_functions</span><span class="p">)</span>  <span class="c1"># type: ignore [arg-type]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">ChainMap</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">base_functions</span><span class="p">)</span>  <span class="c1"># type: ignore [arg-type]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="n">base_functions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;activation: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;functions: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.sub_evaluator">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.sub_evaluator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sub_evaluator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Evaluator&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an evaluator for a sub-expression in a macro.</span>
<span class="sd">        :param ast: The AST for the expression in the macro.</span>
<span class="sd">        :return: A new `Evaluator` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Evaluator</span><span class="p">(</span><span class="n">ast</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span> <span class="n">functions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.set_activation">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.set_activation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_activation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Evaluator&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Chain a new activation using the given Context.</span>
<span class="sd">        This is used for two things:</span>

<span class="sd">        1. Bind external variables like command-line arguments or environment variables.</span>

<span class="sd">        2. Build local variable(s) for macro evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_activation</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">load_values</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Activation: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Evaluator.ident_value">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.ident_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ident_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">root_scope</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result_Function</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resolve names in the current activation.</span>
<span class="sd">        This includes variables, functions, the type registry for conversions,</span>
<span class="sd">        and protobuf packages, as well as protobuf types.</span>

<span class="sd">        We may be limited to root scope, which prevents searching through alternative</span>
<span class="sd">        protobuf package definitions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">.</span><span class="n">resolve_variable</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


<div class="viewcode-block" id="Evaluator.evaluate">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.evaluate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate this AST and return the value or raise an exception.</span>

<span class="sd">        There are two variant use cases.</span>

<span class="sd">        -   External clients want the value or the exception.</span>

<span class="sd">        -   Internally, we sometimes want to silence CELEvalError exceptions so that</span>
<span class="sd">            we can apply short-circuit logic and choose a non-exceptional result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.visit_children">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.visit_children">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">visit_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extend the superclass to track nesting and current evaluation context.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Evaluator.function_eval">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.function_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">function_eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name_token</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">exprlist</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Result</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function evaluation.</span>

<span class="sd">        - Object creation and type conversions.</span>
<span class="sd">        - Other built-in functions like size()</span>
<span class="sd">        - Extension functions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">function</span><span class="p">:</span> <span class="n">CELFunction</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># TODO: Transitive Lookup of function in all parent activation contexts.</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">name_token</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;undeclared reference to &#39;</span><span class="si">{</span><span class="n">name_token</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(in activation &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>
            <span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">name_token</span><span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exprlist</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">exprlist</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">list_exprlist</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">exprlist</span> <span class="ow">or</span> <span class="p">[])</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">list_exprlist</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                <span class="s2">&quot;return error for overflow&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">name_token</span>
            <span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;function_eval(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name_token</span><span class="p">,</span> <span class="n">exprlist</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                <span class="s2">&quot;no such overload&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">name_token</span>
            <span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="Evaluator.method_eval">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.method_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">method_eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="nb">object</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span>
        <span class="n">method_ident</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span>
        <span class="n">exprlist</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Result</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method evaluation. While are (nominally) attached to an object, the only thing</span>
<span class="sd">        actually special is that the object is the first parameter to a function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">function</span><span class="p">:</span> <span class="n">CELFunction</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># TODO: Transitive Lookup of function in all parent activation contexts.</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">method_ident</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;method_eval(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="n">method_ident</span><span class="p">,</span> <span class="n">exprlist</span><span class="p">,</span> <span class="n">ex</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;functions: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span>
            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;undeclared reference to </span><span class="si">{</span><span class="n">method_ident</span><span class="o">.</span><span class="n">value</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(in activation &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>
            <span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">method_ident</span><span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">object</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exprlist</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">exprlist</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">list_exprlist</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">exprlist</span> <span class="ow">or</span> <span class="p">[])</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="o">*</span><span class="n">list_exprlist</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                <span class="s2">&quot;return error for overflow&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">method_ident</span>
            <span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;method_eval(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="n">method_ident</span><span class="p">,</span> <span class="n">exprlist</span><span class="p">,</span> <span class="n">ex</span>
            <span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                <span class="s2">&quot;no such overload&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">method_ident</span>
            <span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="Evaluator.macro_has_eval">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.macro_has_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">macro_has_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprlist</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The has(e.f) macro.</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#field-selection</span>

<span class="sd">        1.  If e evaluates to a map, then has(e.f) indicates whether the string f is a</span>
<span class="sd">            key in the map (note that f must syntactically be an identifier).</span>

<span class="sd">        2.  If e evaluates to a message and f is not a declared field for the message,</span>
<span class="sd">            has(e.f) raises a no_such_field error.</span>

<span class="sd">        3.  If e evaluates to a protocol buffers version 2 message and f is a defined field:</span>

<span class="sd">            - If f is a repeated field or map field, has(e.f) indicates whether the field is</span>
<span class="sd">              non-empty.</span>

<span class="sd">            - If f is a singular or oneof field, has(e.f) indicates whether the field is set.</span>

<span class="sd">        4.  If e evaluates to a protocol buffers version 3 message and f is a defined field:</span>

<span class="sd">            - If f is a repeated field or map field, has(e.f) indicates whether the field is</span>
<span class="sd">              non-empty.</span>

<span class="sd">            - If f is a oneof or singular message field, has(e.f) indicates whether the field</span>
<span class="sd">              is set.</span>

<span class="sd">            - If f is some other singular field, has(e.f) indicates whether the field&#39;s value</span>
<span class="sd">              is its default value (zero for numeric fields, false for booleans,</span>
<span class="sd">              empty for strings and bytes).</span>

<span class="sd">        5.  In all other cases, has(e.f) evaluates to an error.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">has_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">exprlist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">has_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">CELEvalError</span><span class="p">))</span></div>


<div class="viewcode-block" id="Evaluator.expr">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.expr">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        expr           : conditionalor [&quot;?&quot; conditionalor &quot;:&quot; expr]</span>

<span class="sd">        The default implementation short-circuits</span>
<span class="sd">        and can ignore a CELEvalError in the two alternative sub-expressions.</span>
<span class="sd">        The conditional sub-expression CELEvalError is propogated out as the result.</span>

<span class="sd">        See https://github.com/google/cel-spec/blob/master/doc/langdef.md#logical-operators</span>

<span class="sd">        &gt; To get traditional left-to-right short-circuiting evaluation of logical operators,</span>
<span class="sd">        as in C or other languages (also called &quot;McCarthy Evaluation&quot;),</span>
<span class="sd">        the expression e1 &amp;&amp; e2 can be rewritten `e1 ? e2 : false`.</span>
<span class="sd">        Similarly, `e1 || e2` can be rewritten `e1 ? true : e2`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># expr is a single conditionalor.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># full conditionalor &quot;?&quot; conditionalor &quot;:&quot; expr.</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s2">&quot;_?_:_&quot;</span><span class="p">]</span>
            <span class="n">cond_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cond_value</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">cond_value</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for _?_:_ &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">cond_value</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad expr node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.conditionalor">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.conditionalor">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">conditionalor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        conditionalor  : [conditionalor &quot;||&quot;] conditionaland</span>

<span class="sd">        The default implementation short-circuits</span>
<span class="sd">        and can ignore an CELEvalError in a sub-expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># conditionaland with no preceding conditionalor.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s2">&quot;_||_&quot;</span><span class="p">]</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">Result</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for _||_ &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad conditionalor node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.conditionaland">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.conditionaland">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">conditionaland</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        conditionaland : [conditionaland &quot;&amp;&amp;&quot;] relation</span>

<span class="sd">        The default implementation short-circuits</span>
<span class="sd">        and can ignore an CELEvalError in a sub-expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># relation with no preceding conditionaland.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s2">&quot;_&amp;&amp;_&quot;</span><span class="p">]</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">Result</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for _&amp;&amp;_ &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad conditionalor node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.relation">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.relation">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">relation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        relation       : [relation_lt | relation_le | relation_ge | relation_gt</span>
<span class="sd">                       | relation_eq | relation_ne | relation_in] addition</span>

<span class="sd">        relation_lt    : relation &quot;&lt;&quot;</span>
<span class="sd">        relation_le    : relation &quot;&lt;=&quot;</span>
<span class="sd">        relation_gt    : relation &quot;&gt;&quot;</span>
<span class="sd">        relation_ge    : relation &quot;&gt;=&quot;</span>
<span class="sd">        relation_eq    : relation &quot;==&quot;</span>
<span class="sd">        relation_ne    : relation &quot;!=&quot;</span>
<span class="sd">        relation_in    : relation &quot;in&quot;</span>

<span class="sd">        This could be refactored into separate methods to skip the lookup.</span>

<span class="sd">        Ideally::</span>

<span class="sd">            values = self.visit_children(tree)</span>
<span class="sd">            func = functions[op_name_map[tree.data]]</span>
<span class="sd">            result = func(*values)</span>

<span class="sd">        The AST doesn&#39;t provide a flat list of values, however.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># addition with no preceding relation.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">left_op</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;relation_lt&quot;</span><span class="p">:</span> <span class="s2">&quot;_&lt;_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_le&quot;</span><span class="p">:</span> <span class="s2">&quot;_&lt;=_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_ge&quot;</span><span class="p">:</span> <span class="s2">&quot;_&gt;=_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_gt&quot;</span><span class="p">:</span> <span class="s2">&quot;_&gt;_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_eq&quot;</span><span class="p">:</span> <span class="s2">&quot;_==_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_ne&quot;</span><span class="p">:</span> <span class="s2">&quot;_!=_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;relation_in&quot;</span><span class="p">:</span> <span class="s2">&quot;_in_&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span>
            <span class="c1"># NOTE: values have the structure [[left], right]</span>
            <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">),</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">Result</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;relation </span><span class="si">%r</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for </span><span class="si">{</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad relation node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.addition">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.addition">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">addition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        addition       : [addition_add | addition_sub] multiplication</span>

<span class="sd">        addition_add   : addition &quot;+&quot;</span>
<span class="sd">        addition_sub   : addition &quot;-&quot;</span>

<span class="sd">        This could be refactored into separate methods to skip the lookup.</span>

<span class="sd">        Ideally::</span>

<span class="sd">            values = self.visit_children(tree)</span>
<span class="sd">            func = functions[op_name_map[tree.data]]</span>
<span class="sd">            result = func(*values)</span>

<span class="sd">        The AST doesn&#39;t provide a flat list of values, however.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># multiplication with no preceding addition.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">left_op</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;addition_add&quot;</span><span class="p">:</span> <span class="s2">&quot;_+_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;addition_sub&quot;</span><span class="p">:</span> <span class="s2">&quot;_-_&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span>
            <span class="c1"># NOTE: values have the structure [[left], right]</span>
            <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">),</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">Result</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;addition </span><span class="si">%r</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for </span><span class="si">{</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                    <span class="s2">&quot;return error for overflow&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span>
                <span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad addition node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.multiplication">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.multiplication">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">multiplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        multiplication : [multiplication_mul | multiplication_div | multiplication_mod] unary</span>

<span class="sd">        multiplication_mul : multiplication &quot;*&quot;</span>
<span class="sd">        multiplication_div : multiplication &quot;/&quot;</span>
<span class="sd">        multiplication_mod : multiplication &quot;%&quot;</span>

<span class="sd">        This could be refactored into separate methods to skip the lookup.</span>

<span class="sd">        Ideally::</span>

<span class="sd">                values = self.visit_children(tree)</span>
<span class="sd">                func = functions[op_name_map[tree.data]]</span>
<span class="sd">                result = func(*values)</span>

<span class="sd">        The AST doesn&#39;t provide a flat list of values, however.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># unary with no preceding multiplication.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">left_op</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;multiplication_div&quot;</span><span class="p">:</span> <span class="s2">&quot;_/_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;multiplication_mul&quot;</span><span class="p">:</span> <span class="s2">&quot;_*_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;multiplication_mod&quot;</span><span class="p">:</span> <span class="s2">&quot;_%_&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span>
            <span class="c1"># NOTE: values have the structure [[left], right]</span>
            <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">),</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">Result</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;multiplication </span><span class="si">%r</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for </span><span class="si">{</span><span class="n">left_op</span><span class="o">.</span><span class="n">data</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                    <span class="s2">&quot;modulus or divide by zero&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span>
                <span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                    <span class="s2">&quot;return error for overflow&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span>
                <span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad multiplication node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.unary">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.unary">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        unary          : [unary_not | unary_neg] member</span>

<span class="sd">        unary_not      : &quot;!&quot;</span>
<span class="sd">        unary_neg      : &quot;-&quot;</span>

<span class="sd">        This should be refactored into separate methods to skip the lookup.</span>

<span class="sd">        ideally::</span>

<span class="sd">            values = self.visit_children(tree)</span>
<span class="sd">            func = functions[op_name_map[tree.data]]</span>
<span class="sd">            result = func(*values)</span>

<span class="sd">        But, values has the structure ``[[], right]``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># member with no preceeding unary_not or unary_neg</span>
            <span class="c1"># TODO: If there are two possible values (namespace v. mapping) chose the namespace.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">op_tree</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;unary_not&quot;</span><span class="p">:</span> <span class="s2">&quot;!_&quot;</span><span class="p">,</span>
                <span class="s2">&quot;unary_neg&quot;</span><span class="p">:</span> <span class="s2">&quot;-_&quot;</span><span class="p">,</span>
            <span class="p">}[</span><span class="n">op_tree</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span>
            <span class="c1"># NOTE: values has the structure [[], right]</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Result</span><span class="p">],</span> <span class="n">Result</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;unary </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found no matching overload for </span><span class="si">{</span><span class="n">op_tree</span><span class="o">.</span><span class="n">data</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span>
                    <span class="s2">&quot;return error for overflow&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span>
                <span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
                <span class="k">return</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad unary node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.build_macro_eval">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.build_macro_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_macro_eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds macro function.</span>

<span class="sd">        For example</span>

<span class="sd">            ``[1, 2, 3].map(n, n/2)``</span>

<span class="sd">        Builds the function = ``lambda n: n/2``.</span>

<span class="sd">        The function will expose exceptions, disabling short-circuit ``||`` and ``&amp;&amp;``.</span>

<span class="sd">        The `child` is a `member_dot_arg` construct:</span>

<span class="sd">        - [0] is the expression to the left of the &#39;.&#39;</span>

<span class="sd">        - [1] is the function, `map`, to the right of the `.`</span>

<span class="sd">        - [2] is the arguments in ()&#39;s.</span>
<span class="sd">          Within this, there are two children: a variable and an expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">var_tree</span><span class="p">,</span> <span class="n">expr_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">args</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="n">identifier</span> <span class="o">=</span> <span class="n">FindIdent</span><span class="o">.</span><span class="n">in_tree</span><span class="p">(</span><span class="n">var_tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">identifier</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># This seems almost impossible.</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad macro node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># nested_eval = Evaluator(ast=expr_tree, activation=self.activation)</span>
        <span class="n">nested_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_evaluator</span><span class="p">(</span><span class="n">ast</span><span class="o">=</span><span class="n">expr_tree</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">sub_expr</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nested_eval</span><span class="o">.</span><span class="n">set_activation</span><span class="p">({</span><span class="n">identifier</span><span class="p">:</span> <span class="n">v</span><span class="p">})</span><span class="o">.</span><span class="n">evaluate</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">sub_expr</span></div>


<div class="viewcode-block" id="Evaluator.build_ss_macro_eval">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.build_ss_macro_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_ss_macro_eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds macro function for short-circuit logical evaluation ignoring exception values.</span>

<span class="sd">        For example</span>

<span class="sd">            ``[1, 2, &#39;hello&#39;].exists(n, n &gt;= 2)``</span>

<span class="sd">        Builds the function = ``lambda n: n &gt;= 2``.</span>

<span class="sd">        The function will swallow exceptions, enabling short-circuit ``||`` and ``&amp;&amp;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">var_tree</span><span class="p">,</span> <span class="n">expr_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">args</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="n">identifier</span> <span class="o">=</span> <span class="n">FindIdent</span><span class="o">.</span><span class="n">in_tree</span><span class="p">(</span><span class="n">var_tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">identifier</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># This seems almost impossible.</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad macro node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># nested_eval = Evaluator(ast=expr_tree, activation=self.activation)</span>
        <span class="n">nested_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_evaluator</span><span class="p">(</span><span class="n">ast</span><span class="o">=</span><span class="n">expr_tree</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">sub_expr</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">nested_eval</span><span class="o">.</span><span class="n">set_activation</span><span class="p">({</span><span class="n">identifier</span><span class="p">:</span> <span class="n">v</span><span class="p">})</span><span class="o">.</span><span class="n">evaluate</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">CELEvalError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ex</span>

        <span class="k">return</span> <span class="n">sub_expr</span></div>


<div class="viewcode-block" id="Evaluator.build_reduce_macro_eval">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.build_reduce_macro_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_reduce_macro_eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Result</span><span class="p">,</span> <span class="n">Result</span><span class="p">],</span> <span class="n">Result</span><span class="p">],</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds macro function and intiial expression for reduce().</span>

<span class="sd">        For example</span>

<span class="sd">            ``[0, 1, 2].reduce(r, i, 0, r + 2*i+1)``</span>

<span class="sd">        Builds the function = ``lambda r, i: r + 2*i+1`` and initial value = 0.</span>

<span class="sd">        The `child` is a `member_dot_arg` construct:</span>

<span class="sd">        - [0] is the expression to the left of the &#39;.&#39;</span>

<span class="sd">        - [1] is the function, `reduce`, to the right of the `.`</span>

<span class="sd">        - [2] is the arguments in ()&#39;s.</span>
<span class="sd">          Within this, there are four children: two variables and two expressions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">reduce_var_tree</span><span class="p">,</span> <span class="n">iter_var_tree</span><span class="p">,</span> <span class="n">init_expr_tree</span><span class="p">,</span> <span class="n">expr_tree</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">args</span><span class="o">.</span><span class="n">children</span>
        <span class="p">)</span>
        <span class="n">reduce_ident</span> <span class="o">=</span> <span class="n">FindIdent</span><span class="o">.</span><span class="n">in_tree</span><span class="p">(</span><span class="n">reduce_var_tree</span><span class="p">)</span>
        <span class="n">iter_ident</span> <span class="o">=</span> <span class="n">FindIdent</span><span class="o">.</span><span class="n">in_tree</span><span class="p">(</span><span class="n">iter_var_tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reduce_ident</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">iter_ident</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># This seems almost impossible.</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad macro node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># nested_eval = Evaluator(ast=expr_tree, activation=self.activation)</span>
        <span class="n">nested_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_evaluator</span><span class="p">(</span><span class="n">ast</span><span class="o">=</span><span class="n">expr_tree</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">sub_expr</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">Result</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">Result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nested_eval</span><span class="o">.</span><span class="n">set_activation</span><span class="p">(</span>
                <span class="p">{</span><span class="n">reduce_ident</span><span class="p">:</span> <span class="n">r</span><span class="p">,</span> <span class="n">iter_ident</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span>
            <span class="p">)</span><span class="o">.</span><span class="n">evaluate</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">sub_expr</span><span class="p">,</span> <span class="n">init_expr_tree</span></div>


<div class="viewcode-block" id="Evaluator.member">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.member">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member         : member_dot | member_dot_arg | member_item | member_object | primary</span>

<span class="sd">        member_dot     : member &quot;.&quot; IDENT</span>
<span class="sd">        member_dot_arg : member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        member_item    : member &quot;[&quot; expr &quot;]&quot;</span>
<span class="sd">        member_object  : member &quot;{&quot; [fieldinits] &quot;}&quot;</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#field-selection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="Evaluator.member_dot">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.member_dot">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">member_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member         : member_dot | member_dot_arg | member_item | member_object | primary</span>

<span class="sd">        member_dot     : member &quot;.&quot; IDENT</span>
<span class="sd">        member_dot_arg : member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        member_item    : member &quot;[&quot; expr &quot;]&quot;</span>
<span class="sd">        member_object  : member &quot;{&quot; [fieldinits] &quot;}&quot;</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#name-resolution</span>

<span class="sd">        -   ``primary``: Variables and Functions: some simple names refer to variables in the</span>
<span class="sd">            execution context, standard functions, or other name bindings provided by the CEL</span>
<span class="sd">            application.</span>

<span class="sd">        -   ``member_dot``: Field selection: appending a period and identifier to an expression</span>
<span class="sd">            could indicate that we&#39;re accessing a field within a protocol buffer or map.</span>
<span class="sd">            See below for **Field Selection**.</span>

<span class="sd">        -   ``member_dot``: Protocol buffer package names: a simple or qualified name could</span>
<span class="sd">            represent an absolute or relative name in the protocol buffer package namespace.</span>
<span class="sd">            Package names must be followed by a message type, enum type, or enum constant.</span>

<span class="sd">        -   ``member_dot``: Protocol buffer message types, enum types, and enum constants:</span>
<span class="sd">            following an optional protocol buffer package name, a simple or qualified name</span>
<span class="sd">            could refer to a message type, and enum type, or an enum constant in the package&#39;s</span>
<span class="sd">            namespace.</span>

<span class="sd">        Field Selection. There are four cases.</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#field-selection</span>

<span class="sd">        - If e evaluates to a message</span>
<span class="sd">          and f is not declared in this message, the runtime error no_such_field is raised.</span>

<span class="sd">        - If e evaluates to a message</span>
<span class="sd">          and f is declared, but the field is not set,</span>
<span class="sd">          the default value of the field&#39;s type will be produced.</span>

<span class="sd">        - If e evaluates to a map, then e.f is equivalent to e[&#39;f&#39;].</span>

<span class="sd">        - In all other cases, e.f evaluates to an error.</span>

<span class="sd">        TODO: implement member &quot;.&quot; IDENT for messages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">member_tree</span><span class="p">,</span> <span class="n">property_name_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span>
        <span class="p">)</span>
        <span class="n">member</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">member_tree</span><span class="p">)</span>
        <span class="n">property_name</span> <span class="o">=</span> <span class="n">property_name_token</span><span class="o">.</span><span class="n">value</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">Result</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">member</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">NameContainer</span><span class="p">):</span>
            <span class="c1"># Navigation through names provided as external run-time bindings.</span>
            <span class="c1"># The dict is the value of a Referent that was part of a namespace path.</span>
            <span class="k">if</span> <span class="n">property_name</span> <span class="ow">in</span> <span class="n">member</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">member</span><span class="p">[</span><span class="n">property_name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;No </span><span class="si">{</span><span class="n">property_name</span><span class="si">!r}</span><span class="s2"> in bindings </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">member</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
        <span class="c1"># TODO: Not sure this is needed...</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MessageType</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;member_dot(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">property_name</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">property_name</span><span class="p">)</span>
        <span class="c1"># TODO: Future Expansion, handle Protobuf message package...</span>
        <span class="c1"># elif isinstance(member, celpy.celtypes.PackageType):</span>
        <span class="c1">#     if property_name in member:</span>
        <span class="c1">#         result = member[property_name]</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         err = f&quot;no such message {property_name!r} in package {member}&quot;</span>
        <span class="c1">#         result = CELEvalError(err, KeyError, None, tree=tree)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">):</span>
            <span class="c1"># Syntactic sugar: a.b is a[&quot;b&quot;] when a is a mapping.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">member</span><span class="p">[</span><span class="n">property_name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;no such member in mapping: </span><span class="si">{</span><span class="n">property_name</span><span class="si">!r}</span><span class="s2">&quot;</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">member</span><span class="si">!r}</span><span class="s2"> with type: &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">member</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; does not support field selection&quot;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Evaluator.member_dot_arg">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.member_dot_arg">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">member_dot_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member         : member_dot | member_dot_arg | member_item | member_object | primary</span>

<span class="sd">        member_dot     : member &quot;.&quot; IDENT</span>
<span class="sd">        member_dot_arg : member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        member_item    : member &quot;[&quot; expr &quot;]&quot;</span>
<span class="sd">        member_object  : member &quot;{&quot; [fieldinits] &quot;}&quot;</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#field-selection</span>

<span class="sd">        Method or macro? We Distinguish between these three similar cases.</span>

<span class="sd">        - Macros: https://github.com/google/cel-spec/blob/master/doc/langdef.md#macros</span>

<span class="sd">        - member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot; -- used for string operations</span>

<span class="sd">        - member &quot;.&quot; IDENT &quot;(&quot; &quot;)&quot;  -- used for a several timestamp operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sub_expr</span><span class="p">:</span> <span class="n">CELFunction</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">Result</span>
        <span class="n">reduction</span><span class="p">:</span> <span class="n">Result</span>
        <span class="n">CELBoolFunction</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">,</span> <span class="n">Result</span><span class="p">],</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span>
        <span class="p">]</span>

        <span class="n">member_tree</span><span class="p">,</span> <span class="n">method_name_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">{</span>
            <span class="s2">&quot;map&quot;</span><span class="p">,</span>
            <span class="s2">&quot;filter&quot;</span><span class="p">,</span>
            <span class="s2">&quot;all&quot;</span><span class="p">,</span>
            <span class="s2">&quot;exists&quot;</span><span class="p">,</span>
            <span class="s2">&quot;exists_one&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reduce&quot;</span><span class="p">,</span>
            <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="p">}:</span>
            <span class="n">member_list</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">member_tree</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member_list</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">member_list</span>

            <span class="k">if</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;map&quot;</span><span class="p">:</span>
                <span class="n">sub_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_macro_eval</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">mapping</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">Iterable</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="nb">map</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">,</span> <span class="n">member_list</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="k">elif</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;filter&quot;</span><span class="p">:</span>
                <span class="n">sub_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_macro_eval</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">,</span> <span class="n">member_list</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="k">elif</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                <span class="n">sub_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_ss_macro_eval</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">and_oper</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">CELBoolFunction</span><span class="p">,</span>
                    <span class="n">eval_error</span><span class="p">(</span><span class="s2">&quot;no such overload&quot;</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)(</span>
                        <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_and</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="n">reduction</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                    <span class="n">and_oper</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">,</span> <span class="n">member_list</span><span class="p">),</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">reduction</span>

            <span class="k">elif</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;exists&quot;</span><span class="p">:</span>
                <span class="n">sub_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_ss_macro_eval</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">or_oper</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">CELBoolFunction</span><span class="p">,</span>
                    <span class="n">eval_error</span><span class="p">(</span><span class="s2">&quot;no such overload&quot;</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)(</span>
                        <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">logical_or</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="n">reduction</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
                    <span class="n">or_oper</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">,</span> <span class="n">member_list</span><span class="p">),</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">reduction</span>

            <span class="k">elif</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;exists_one&quot;</span><span class="p">:</span>
                <span class="c1"># Is there exactly 1?</span>
                <span class="n">sub_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_macro_eval</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">member_list</span> <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
                <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;reduce&quot;</span><span class="p">:</span>
                <span class="c1"># Apply a function to reduce the list to a single value.</span>
                <span class="c1"># The `tree` is a `member_dot_arg` construct with (member, method_name, args)</span>
                <span class="c1"># The args have two variables and two expressions.</span>
                <span class="n">reduce_expr</span><span class="p">,</span> <span class="n">init_expr_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_reduce_macro_eval</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="n">initial_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">init_expr_tree</span><span class="p">)</span>
                <span class="n">reduction</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">reduce_expr</span><span class="p">,</span> <span class="n">member_list</span><span class="p">,</span> <span class="n">initial_value</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">reduction</span>

            <span class="k">elif</span> <span class="n">method_name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
                <span class="c1"># Special case of &quot;reduce()&quot;</span>
                <span class="c1"># with &lt;member&gt;.min() -&gt; &lt;member&gt;.reduce(r, i, int_max, r &lt; i ? r : i)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Note. The Result type includes None, which will raise an exception.</span>
                    <span class="n">reduction</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">member_list</span><span class="p">)</span>  <span class="c1"># type: ignore [type-var]</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                    <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Attempt to reduce an empty sequence or a sequence with a None value&quot;</span>
                    <span class="n">reduction</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">reduction</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Internal Design Error&quot;</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Not a macro: a method evaluation.</span>
            <span class="c1"># Evaluate member, method IDENT and (if present) exprlist and apply.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">member</span><span class="p">,</span> <span class="n">ident</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">Tuple</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_eval</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">ident</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># assert len(tree.children) == 3</span>
                <span class="n">member</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">expr_iter</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">Tuple</span><span class="p">[</span><span class="n">Result</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Result</span><span class="p">]],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_eval</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">expr_iter</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Evaluator.member_index">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.member_index">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">member_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member         : member_dot | member_dot_arg | member_item | member_object | primary</span>

<span class="sd">        member_dot     : member &quot;.&quot; IDENT</span>
<span class="sd">        member_dot_arg : member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        member_item    : member &quot;[&quot; expr &quot;]&quot;</span>
<span class="sd">        member_object  : member &quot;{&quot; [fieldinits] &quot;}&quot;</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#field-selection</span>

<span class="sd">        Locating an item in a Mapping or List</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s2">&quot;_[_]&quot;</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="n">member</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;found no matching overload for _[_] &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;applied to &#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">member</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">)&#39;&quot;</span>
            <span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="s2">&quot;no such key&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">) --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">member</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="s2">&quot;invalid_argument&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="n">value</span><span class="o">.</span><span class="n">__cause__</span> <span class="o">=</span> <span class="n">ex</span>
            <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="Evaluator.member_object">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.member_object">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">member_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        member         : member_dot | member_dot_arg | member_item | member_object | primary</span>

<span class="sd">        member_dot     : member &quot;.&quot; IDENT</span>
<span class="sd">        member_dot_arg : member &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        member_item    : member &quot;[&quot; expr &quot;]&quot;</span>
<span class="sd">        member_object  : member &quot;{&quot; [fieldinits] &quot;}&quot;</span>

<span class="sd">        https://github.com/google/cel-spec/blob/master/doc/langdef.md#field-selection</span>

<span class="sd">        An object constructor requires a protobyf type, not an object as the &quot;member&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># primary | member &quot;{&quot; &quot;}&quot;</span>
            <span class="k">if</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;primary&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Build a default protobuf message.</span>
                <span class="n">protobuf_class</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Creating </span><span class="si">%s</span><span class="s2">()&quot;</span><span class="p">,</span> <span class="n">protobuf_class</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">protobuf_class</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Created </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># protobuf feature:  member &quot;{&quot; fieldinits &quot;}&quot;</span>
            <span class="n">member</span><span class="p">,</span> <span class="n">fieldinits</span> <span class="o">=</span> <span class="n">values</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">member</span>
            <span class="c1"># Apply fieldinits as the constructor for an instance of the referenced type.</span>
            <span class="n">protobuf_class</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">member</span><span class="p">)</span>
            <span class="c1"># NOTE: protobuf MessageType conversions are the responsibility of the target type.</span>
            <span class="c1"># We can&#39;t -- easily -- generalize this.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Creating </span><span class="si">%s</span><span class="s2">(</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">protobuf_class</span><span class="p">,</span> <span class="n">fieldinits</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">protobuf_class</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="n">fieldinits</span><span class="p">))</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Created </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad member_object node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.primary">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.primary">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">primary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        primary        : dot_ident_arg | dot_ident | ident_arg | ident</span>
<span class="sd">                       | paren_expr | list_lit | map_lit | literal</span>

<span class="sd">        dot_ident_arg  : &quot;.&quot; IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        dot_ident      : &quot;.&quot; IDENT</span>
<span class="sd">        ident_arg      : IDENT &quot;(&quot; [exprlist] &quot;)&quot;</span>
<span class="sd">        ident          : IDENT</span>
<span class="sd">        paren_expr     : &quot;(&quot; expr &quot;)&quot;</span>
<span class="sd">        list_lit       : &quot;[&quot; [exprlist] &quot;]&quot;</span>
<span class="sd">        map_lit        : &quot;{&quot; [mapinits] &quot;}&quot;</span>

<span class="sd">        TODO: Refactor into separate methods to skip this complex elif chain.</span>
<span class="sd">        top-level :py:meth:`primary` is similar to :py:meth:`method`.</span>
<span class="sd">        Each of the individual rules then works with a tree instead of a child of the</span>
<span class="sd">        primary tree.</span>

<span class="sd">        This includes function-like macros: has() and dyn().</span>
<span class="sd">        These are special cases and cannot be overridden.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">Result</span>
        <span class="n">name_token</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad primary node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">child</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;literal&quot;</span><span class="p">:</span>
            <span class="c1"># A literal value</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;paren_expr&quot;</span><span class="p">:</span>
            <span class="c1"># A &quot;(&quot; expr &quot;)&quot;</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;list_lit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Empty list</span>
                <span class="c1"># TODO: Refactor into type_eval()</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># exprlist to be packaged as List.</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;map_lit&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Empty mapping</span>
                <span class="c1"># TODO: Refactor into type_eval()</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># mapinits (a sequence of key-value tuples) to be packaged as a dict.</span>
                <span class="c1"># OR. An CELEvalError in case of ValueError caused by duplicate keys.</span>
                <span class="c1"># OR. An CELEvalError in case of TypeError cause by invalid key types.</span>
                <span class="c1"># TODO: Refactor into type_eval()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;dot_ident&quot;</span><span class="p">,</span> <span class="s2">&quot;dot_ident_arg&quot;</span><span class="p">):</span>
            <span class="c1"># &quot;.&quot; IDENT [&quot;(&quot; [exprlist] &quot;)&quot;]</span>
            <span class="c1"># Leading &quot;.&quot; means the name is resolved in the root scope **only**.</span>
            <span class="c1"># No searching through alterantive packages.</span>
            <span class="c1"># len(child) == 1 -- &quot;.&quot; IDENT</span>
            <span class="c1"># len(child) == 2 -- &quot;.&quot; IDENT &quot;(&quot; exprlist &quot;)&quot; -- TODO: Implement dot_ident_arg.</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="n">name_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Should not be a Function, should only be a Result</span>
            <span class="c1"># TODO: implement dot_ident_arg uses function_eval().</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">Result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ident_value</span><span class="p">(</span><span class="n">name_token</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">root_scope</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;ident_arg&quot;</span><span class="p">:</span>
            <span class="c1"># IDENT [&quot;(&quot; [exprlist] &quot;)&quot;]</span>
            <span class="c1"># Can be a proper function or one of the function-like macros: &quot;has()&quot;, &quot;dyn()&quot;.</span>
            <span class="n">exprlist</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">name_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">exprlist</span> <span class="o">=</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;exprlist&quot;</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">name_token</span><span class="p">,</span> <span class="n">exprlist</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">],</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>  <span class="c1"># pragma: no cover</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad primary node&quot;</span><span class="p">,</span>
                    <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                    <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;has&quot;</span><span class="p">:</span>
                <span class="c1"># has() macro. True if the child expression is a member expression that evaluates.</span>
                <span class="c1"># False if the child expression is a member expression that cannot be evaluated.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">macro_has_eval</span><span class="p">(</span><span class="n">exprlist</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;dyn&quot;</span><span class="p">:</span>
                <span class="c1"># dyn() macro does nothing; it&#39;s for run-time type-checking.</span>
                <span class="n">dyn_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">exprlist</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">dyn_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Ordinary function() evaluation.</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">exprlist</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_eval</span><span class="p">(</span>
                    <span class="n">name_token</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="n">Iterable</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="n">values</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="s2">&quot;ident&quot;</span><span class="p">:</span>
            <span class="c1"># IDENT -- simple identifier from the current activation.</span>
            <span class="n">name_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Should not be a Function.</span>
                <span class="c1"># Generally Result object (i.e., a variable)</span>
                <span class="c1"># Could be an Annotation object (i.e., a type) for protobuf messages</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ident_value</span><span class="p">(</span><span class="n">name_token</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;undeclared reference to &#39;</span><span class="si">{</span><span class="n">name_token</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(in activation &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad primary node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.literal">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.literal">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a literal from the token at the top of the parse tree.</span>

<span class="sd">        ..  todo:: Use type provider conversions from string to CEL type objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: bad literal node&quot;</span><span class="p">,</span>
                <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">value_token</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span><span class="p">:</span> <span class="n">Result</span>
            <span class="k">if</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;FLOAT_LIT&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">DoubleType</span><span class="p">(</span><span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;INT_LIT&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;UINT_LIT&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;u&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">CELSyntaxError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;invalid unsigned int literal </span><span class="si">{</span><span class="n">value_token</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">line</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                        <span class="n">column</span><span class="o">=</span><span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">UintType</span><span class="p">(</span><span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;MLSTRING_LIT&quot;</span><span class="p">,</span> <span class="s2">&quot;STRING_LIT&quot;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">celstr</span><span class="p">(</span><span class="n">value_token</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;BYTES_LIT&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">celbytes</span><span class="p">(</span><span class="n">value_token</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;BOOL_LIT&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BoolType</span><span class="p">(</span><span class="n">value_token</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;NULL_LIT&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CELUnsupportedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">: type not implemented&quot;</span><span class="p">,</span>
                    <span class="n">line</span><span class="o">=</span><span class="n">value_token</span><span class="o">.</span><span class="n">line</span> <span class="ow">or</span> <span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                    <span class="n">column</span><span class="o">=</span><span class="n">value_token</span><span class="o">.</span><span class="n">column</span> <span class="ow">or</span> <span class="n">tree</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">CELEvalError</span><span class="p">(</span><span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ex</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Evaluator.exprlist">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.exprlist">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">exprlist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        exprlist       : expr (&quot;,&quot; expr)*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">CELEvalError</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># There are no CELEvalError values in the result, so we can narrow the domain.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">ListType</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="n">values</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Evaluator.fieldinits">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.fieldinits">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fieldinits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        fieldinits     : IDENT &quot;:&quot; expr (&quot;,&quot; IDENT &quot;:&quot; expr)*</span>

<span class="sd">        The even items, children[0::2] are identifiers, nothing to evaluate.</span>
<span class="sd">        The odd items, childnre[1::2] are expressions.</span>

<span class="sd">        This creates a mapping, used by the :meth:`member_object` method to create</span>
<span class="sd">        and populate a protobuf object. Duplicate names are an error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">,</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">]],</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">ident_node</span><span class="p">,</span> <span class="n">expr_node</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="n">ident</span> <span class="o">=</span> <span class="n">ident_node</span><span class="o">.</span><span class="n">value</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">expr_node</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ident</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Duplicate field label </span><span class="si">{</span><span class="n">ident</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fields</span><span class="p">[</span><span class="n">ident</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MessageType</span><span class="p">(</span><span class="o">**</span><span class="n">fields</span><span class="p">)</span></div>


<div class="viewcode-block" id="Evaluator.mapinits">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.Evaluator.mapinits">[docs]</a>
    <span class="nd">@trace</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mapinits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        mapinits       : expr &quot;:&quot; expr (&quot;,&quot; expr &quot;:&quot; expr)*</span>

<span class="sd">        Extract the key expr&#39;s and value expr&#39;s to a list of pairs.</span>
<span class="sd">        This raises an exception on a duplicate key.</span>

<span class="sd">        TODO: Is ``{&#39;a&#39;: 1, &#39;b&#39;: 2/0}[&#39;a&#39;]`` a meaningful result in CEL?</span>
<span class="sd">        Or is this an error because the entire member is erroneous?</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">MapType</span><span class="p">()</span>

        <span class="c1"># Not sure if this cast is sensible. Should a CELEvalError propagate up from the</span>
        <span class="c1"># sub-expressions? See the error check in :py:func:`exprlist`.</span>
        <span class="n">keys_values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">Value</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_children</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys_values</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">keys_values</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Duplicate key </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">result</span></div>
</div>



<span class="n">CEL_ESCAPES_PAT</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">[abfnrtv</span><span class="se">\&quot;</span><span class="s2">&#39;</span><span class="se">\\\\</span><span class="s2">]|</span><span class="se">\\\\\\</span><span class="s2">d</span><span class="si">{3}</span><span class="s2">|</span><span class="se">\\\\</span><span class="s2">x[0-9a-fA-F]</span><span class="si">{2}</span><span class="s2">|</span><span class="se">\\\\</span><span class="s2">u[0-9a-fA-F]</span><span class="si">{4}</span><span class="s2">|</span><span class="se">\\\\</span><span class="s2">U[0-9a-fA-F]</span><span class="si">{8}</span><span class="s2">|.&quot;</span>
<span class="p">)</span>


<span class="n">CEL_ESCAPES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">a&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\a</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">b&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\b</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">f&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\f</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">r&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">t&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">v&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\v</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">:</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&#39;&quot;</span><span class="p">:</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="celstr">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.celstr">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">celstr</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a CEL string literal, expanding escapes to create a Python string.</span>

<span class="sd">    It may be that built-in ``eval()`` might work for some of this, but</span>
<span class="sd">    the octal escapes aren&#39;t really viable.</span>

<span class="sd">    :param token: CEL token value</span>
<span class="sd">    :return: str</span>

<span class="sd">    ..  todo:: This can be refactored into celpy.celtypes.StringType.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">expand</span><span class="p">(</span><span class="n">match_iter</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Match</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">match_iter</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">expanded</span> <span class="o">=</span> <span class="n">match</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sa">r</span><span class="s2">&quot;\x&quot;</span><span class="p">:</span>
                <span class="n">expanded</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">16</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="p">{</span><span class="sa">r</span><span class="s2">&quot;\u&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\U&quot;</span><span class="p">}:</span>
                <span class="n">expanded</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">16</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">expanded</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">8</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expanded</span> <span class="o">=</span> <span class="n">CEL_ESCAPES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">expanded</span>

    <span class="n">text</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="n">text</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">):</span>
        <span class="c1"># Raw; ignore ``\`` escapes</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&quot;&quot;&#39;</span> <span class="ow">or</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&#39;&#39;&#39;&quot;</span><span class="p">:</span>
            <span class="c1"># Long</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Short</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Cooked; expand ``\`` escapes</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&quot;&quot;&#39;</span> <span class="ow">or</span> <span class="n">text</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&#39;&#39;&#39;&quot;</span><span class="p">:</span>
            <span class="c1"># Long</span>
            <span class="n">match_iter</span> <span class="o">=</span> <span class="n">CEL_ESCAPES_PAT</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Short</span>
            <span class="n">match_iter</span> <span class="o">=</span> <span class="n">CEL_ESCAPES_PAT</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">expanded</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">match_iter</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">StringType</span><span class="p">(</span><span class="n">expanded</span><span class="p">)</span></div>



<div class="viewcode-block" id="celbytes">
<a class="viewcode-back" href="../../api.html#celpy.evaluation.celbytes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">celbytes</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="n">lark</span><span class="o">.</span><span class="n">Token</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BytesType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a CEL bytes literal, expanding escapes to create a Python bytes object.</span>

<span class="sd">    :param token: CEL token value</span>
<span class="sd">    :return: bytes</span>

<span class="sd">    ..  todo:: This can be refactored into celpy.celtypes.BytesType.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">expand</span><span class="p">(</span><span class="n">match_iter</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Match</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">match_iter</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">match</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sa">r</span><span class="s2">&quot;\x&quot;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">16</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sa">r</span><span class="s2">&quot;\u&quot;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">16</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">8</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">ord</span><span class="p">(</span><span class="n">CEL_ESCAPES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">match</span><span class="p">))</span>

    <span class="n">text</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="n">text</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;br&quot;</span><span class="p">:</span>
        <span class="c1"># Raw; ignore ``\`` escapes</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&quot;&quot;&#39;</span> <span class="ow">or</span> <span class="n">text</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&#39;&#39;&#39;&quot;</span><span class="p">:</span>
            <span class="c1"># Long</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BytesType</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">text</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Short</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BytesType</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">text</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">text</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
        <span class="c1"># Cooked; expand ``\`` escapes</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&quot;&quot;&#39;</span> <span class="ow">or</span> <span class="n">text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&#39;&#39;&#39;&quot;</span><span class="p">:</span>
            <span class="c1"># Long</span>
            <span class="n">match_iter</span> <span class="o">=</span> <span class="n">CEL_ESCAPES_PAT</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Short</span>
            <span class="n">match_iter</span> <span class="o">=</span> <span class="n">CEL_ESCAPES_PAT</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">expanded</span> <span class="o">=</span> <span class="n">celpy</span><span class="o">.</span><span class="n">celtypes</span><span class="o">.</span><span class="n">BytesType</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">match_iter</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid bytes literal </span><span class="si">{</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expanded</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">CEL in Python</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">CLI Use of CEL-Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../integration.html">Application Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">CEL-Py API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../structure.html">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../c7n_functions.html">C7N Functions Required</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2020, CapitalOne.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>